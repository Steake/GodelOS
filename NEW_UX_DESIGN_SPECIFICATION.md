# GödelOS UX/UI Redesign Specification

*Based on comprehensive codebase analysis - May 29, 2025*

## Executive Summary

After thorough analysis of the actual backend capabilities and frontend impl### 5. System Evolution & Self-Modification Interface

**Critical Gap**: The current interface doesn't expose the system's self-modification capabilities or capability tracking
**Solution**: Dedicated interfaces for cognitive evolution and system health

#### 5.1 Cognitive Capability Dashboard
```
┌─────────────────────────────────────────────┐
│ 🧠 GödelOS Cognitive Capabilities           │
├─────────────────────────────────────────────┤
│ Current Capabilities:                        │
│ ✓ Analogical Reasoning      ████████▓▓ 85%  │ ← Real-time
│ ✓ Knowledge Integration     ██████▓▓▓▓ 65%  │   capability
│ ✓ Creative Problem Solving  ███████▓▓▓ 73%  │   assessment
│ ⚠ Abstract Mathematics      ████▓▓▓▓▓▓ 42%  │
│ ❌ Visual Reasoning          ▓▓▓▓▓▓▓▓▓▓ 15%  │
│                                             │
│ 📈 Capability Trends (7 days):              │
│ • Analogical Reasoning: +12% improvement    │ ← Learning
│ • Knowledge Integration: +8% improvement    │   progress
│ • Mathematical Reasoning: -3% decline       │   tracking
│                                             │
│ 🎯 Learning Focus Areas:                    │
│ 1. Visual pattern recognition               │ ← System-identified
│ 2. Mathematical proof strategies            │   growth areas
│ 3. Temporal reasoning improvement           │
│                                             │
│ [View Detailed Analysis] [Adjust Focus]     │
└─────────────────────────────────────────────┘
```

#### 5.2 Self-Modification Proposals Interface
```
┌─────────────────────────────────────────────┐
│ 🔧 System Improvement Proposals             │
├─────────────────────────────────────────────┤
│ Active Proposals (3):                       │
│                                             │
│ 🔥 High Priority:                           │
│ ┌─────────────────────────────────────────┐ │
│ │ Optimize Reflection Depth Strategy      │ │ ← System-generated
│ │ Current: Fixed 3-level max              │ │   improvement
│ │ Proposed: Adaptive depth based on      │ │   suggestions
│ │          complexity & cognitive load    │ │
│ │ Expected Impact: 23% faster reasoning  │ │
│ │ Risk Level: Low                        │ │
│ │ [Approve] [Review Details] [Decline]   │ │
│ └─────────────────────────────────────────┘ │
│                                             │
│ 📊 Medium Priority:                         │
│ ┌─────────────────────────────────────────┐ │
│ │ Enhance Analogical Pattern Matching    │ │
│ │ Add semantic embedding comparison to   │ │
│ │ structural similarity detection        │ │
│ │ Expected Impact: 15% better analogies │ │
│ │ [Review] [Test Mode] [Defer]          │ │
│ └─────────────────────────────────────────┘ │
│                                             │
│ 📈 Implementation History:                  │
│ • Template Evolution Optimization (✓ Active)│ ← Track what
│ • Knowledge Graph Reorganization (Testing) │   changes were
│ • Meta-Reflection Frequency Tuning (Failed)│   implemented
│                                             │
│ [Propose Custom Modification]               │
└─────────────────────────────────────────────┘
```

#### 5.3 Real-Time Cognitive State Monitor
```
┌─────────────────────────────────────────────┐
│ 📊 Live Cognitive State                     │
├─────────────────────────────────────────────┤
│ Manifest Consciousness:                     │
│ 🎯 Attention: "Solving physics problem"     │ ← What system
│ 🧮 Working Memory: 7/12 slots occupied     │   is actively
│ ⚡ Processing Load: ████▓▓▓▓▓▓ 45%         │   focused on
│                                             │
│ Agentic Processes (4 active):               │
│ • Agent-A: Hypothesis generation [Physics]  │ ← Independent
│ • Agent-B: Knowledge retrieval [Mathematics]│   cognitive
│ • Agent-C: Analogy search [Biology→Physics] │   agents
│ • Agent-D: Contradiction checking [Logic]   │
│                                             │
│ Daemon Threads (6 running):                 │
│ 🔄 Memory consolidation      Active         │ ← Background
│ 🔍 Pattern discovery         Active         │   processes
│ 📚 Knowledge reorganization   Idle          │
│ 🎭 Creative synthesis         Active        │
│ 🔧 Strategy optimization      Scheduled     │
│ 📈 Performance monitoring     Active        │
│                                             │
│ System Health:                              │
│ • Inference Engine: ████████▓▓ 87% healthy │
│ • Knowledge Store: █████████▓ 94% healthy  │ ← Component
│ • Reflection Engine: ██████▓▓▓ 71% healthy │   health
│ • Learning Modules: ████████▓▓ 85% healthy │   monitoring
│                                             │
│ ⚠️ Alerts:                                  │
│ • Reflection Engine showing minor slowdown │
│ • Knowledge Store approaching 80% capacity │
└─────────────────────────────────────────────┘
```

#### 5.4 Architecture Evolution Timeline
```
┌─────────────────────────────────────────────┐
│ 📈 Cognitive Architecture Evolution         │
├─────────────────────────────────────────────┤
│ Timeline View:                              │
│ ──●─────●──────●─────●────●─────→           │
│   │     │      │     │    │     Now         │
│   │     │      │     │    └ Template Opt   │
│   │     │      │     └ Meta-Reflection+    │ ← Major
│   │     │      └ Analogical Engine v2.1    │   architecture
│   │     └ Knowledge Integration Boost      │   changes over
│   └ Base Architecture                      │   time
│                                             │
│ Current Version: v2.3.7                    │
│ • 847 reasoning templates learned          │
│ • 23 cognitive strategies optimized        │ ← Quantified
│ • 156 self-modifications implemented       │   system
│ • 12 major capability breakthroughs        │   evolution
│                                             │
│ Upcoming Planned Changes:                   │
│ 📅 Next Week: Uncertainty quantification   │
│ 📅 Next Month: Visual reasoning module     │ ← Future
│ 📅 Q3 2025: Emotional reasoning layer      │   roadmap
│                                             │
│ [Export Evolution Report] [Compare Versions]│
└─────────────────────────────────────────────┘
```

### 6. Advanced Cognitive Transparency Features

#### 6.1 Multi-Level Reflection Visualization
```
┌─────────────────────────────────────────────┐
│ 🔄 Reflection Depth Visualization           │
├─────────────────────────────────────────────┤
│ Query: "Is democracy the best form of govt?"│
│                                             │
│ Level 1: Direct Analysis                    │
│ ├─ Democracy has accountability mechanisms  │
│ ├─ Historically stable in developed nations │ ← Basic
│ └─ Vulnerable to populism and manipulation  │   reflection
│                                             │
│ ⟲ Level 2: Meta-Analysis                   │
│ ├─ My analysis assumes Western perspective  │
│ ├─ "Best" implies single optimization goal │ ← Thinking about
│ └─ Historical data may not predict future  │   thinking
│                                             │
│ ⟲ Level 3: Meta-Meta-Analysis              │
│ ├─ I'm revealing my own cognitive biases   │
│ ├─ Question may be fundamentally unanswer  │ ← Thinking about
│ └─ My uncertainty itself reveals epistem   │   thinking about
│                                             │   thinking
│ 🎭 Perspective Shifts Detected:             │
│ • Initial confidence → Epistemic humility  │
│ • Factual analysis → Philosophical inquiry │
│ • Single answer → Multiple valid frames    │
└─────────────────────────────────────────────┘
```

#### 6.2 Cognitive Load & Resource Allocation
```
┌─────────────────────────────────────────────┐
│ ⚡ Cognitive Resource Allocation             │
├─────────────────────────────────────────────┤
│ Current Query Processing:                   │
│                                             │
│ 🧠 Reasoning Engine      ████████▓▓ 83%     │ ← Real-time
│ 📚 Knowledge Retrieval   ██████▓▓▓▓ 67%     │   resource
│ 🔍 Pattern Matching      █████▓▓▓▓▓ 54%     │   usage
│ 🎭 Creative Generation   ███▓▓▓▓▓▓▓ 34%     │
│ 🔄 Reflection Processes  ██████████ 100%    │
│                                             │
│ 📊 Allocation Strategy: "Depth-First"      │
│ Alternative Strategies Available:           │
│ • Breadth-First (explore more options)     │ ← User can
│ • Balanced (equal resource distribution)   │   influence
│ • Creative-Focus (emphasize novel ideas)   │   thinking
│ • Fast-Response (minimize processing time) │   style
│                                             │
│ 🎯 Attention Bottlenecks:                  │
│ • Reflection engine at capacity            │
│ • Knowledge retrieval queue: 7 pending     │ ← System
│ • Working memory: near limit               │   constraints
│                                             │
│ [Adjust Strategy] [Add Resources] [Optimize]│
└─────────────────────────────────────────────┘
```

### 7. Collaborative Intelligence Features

#### 7.1 Human-AI Cognitive Partnership
```
┌─────────────────────────────────────────────┐
│ 🤝 Collaborative Reasoning Session          │
├─────────────────────────────────────────────┤
│ Joint Analysis: "Climate change solutions"  │
│                                             │
│ 🤖 GödelOS Contribution:                    │
│ • Generated 23 potential approaches         │
│ • Identified 7 key constraint factors      │ ← System
│ • Found analogies from urban planning      │   contributions
│ • Assessed feasibility (confidence: 73%)   │
│                                             │
│ 👤 Human Contribution:                      │
│ • Political feasibility concerns           │
│ • Cultural acceptance factors              │ ← Human
│ • Real-world implementation challenges     │   expertise
│ • Ethical considerations                   │
│                                             │
│ 🎯 Collaborative Insights:                 │
│ • Combined technical + social analysis     │
│ • Novel hybrid approaches identified       │ ← Emergent
│ • Risk mitigation strategies developed     │   insights
│                                             │
│ Next Steps:                                 │
│ 🤖 "I'll research carbon capture economics" │
│ 👤 "I'll check policy implementation cases"│
│                                             │
│ [Continue Session] [Save Analysis] [Export] │
└─────────────────────────────────────────────┘
```

#### 7.2 System Learning from Interaction
```
┌─────────────────────────────────────────────┐
│ 📚 Learning from Human Feedback             │
├─────────────────────────────────────────────┤
│ Session Summary:                            │
│ • 47 minutes of collaborative reasoning     │
│ • 12 human corrections received            │
│ • 8 new reasoning patterns learned         │ ← System
│ • 3 cognitive strategies updated           │   adaptation
│                                             │
│ Key Learning Points:                        │
│ ✓ "Political feasibility often outweighs   │
│    technical optimality in policy design"  │ ← Learned
│ ✓ "Cultural context affects adoption more  │   principles
│    than economic incentives"               │
│ ✓ "Implementation timeline assumptions     │
│    were consistently overoptimistic"       │
│                                             │
│ Cognitive Updates Applied:                  │
│ • Enhanced policy analysis templates       │
│ • Improved cultural factor weighting       │ ← Concrete
│ • Adjusted timeline estimation models      │   improvements
│                                             │
│ Learning Confidence: ████████▓▓ 87%        │
│ Integration Status: Testing (24h trial)    │
│                                             │
│ [Approve Integration] [Extend Testing]      │
└─────────────────────────────────────────────┘
```

### 8. Knowledge Evolution Tracking

#### 8.1 Concept Evolution Visualization
```
┌─────────────────────────────────────────────┐
│ 🌱 Knowledge Evolution: "Artificial Intelligence" │
├─────────────────────────────────────────────┤
│ Concept Development Timeline:               │
│                                             │
│ 2024-03-15: Initial definition             │
│ ├─ "Computer systems that mimic human..."  │ ← Concept
│                                             │   maturation
│ 2024-04-22: Nuanced understanding          │   over time
│ ├─ Added: Machine learning subcategories   │
│ ├─ Added: Ethical considerations           │
│                                             │
│ 2024-05-29: Integrated perspective         │
│ ├─ Connected: Cognitive architecture       │
│ ├─ Integrated: Philosophy of mind          │
│ ├─ Synthesized: Multiple paradigms         │
│                                             │
│ Current Understanding Depth:                │
│ Technical Aspects:    ████████▓▓ 87%       │ ← Multi-dimensional
│ Philosophical Issues: ██████▓▓▓▓ 65%       │   knowledge
│ Societal Impact:      ███████▓▓▓ 74%       │   assessment
│ Historical Context:   █████▓▓▓▓▓ 56%       │
│                                             │
│ 🔗 Knowledge Connections (847 total):       │
│ • Strong links: Cognition, Computing       │
│ • Emerging links: Ethics, Philosophy       │ ← Relationship
│ • Weak links: Art, Literature              │   strength
│                                             │
│ [View Full Evolution] [Export Timeline]     │
└─────────────────────────────────────────────┘
```
mentation, this specification addresses the real issues identified:
- **Duplicate transparency panels** in HTML structure
- **Fragmented knowledge ingestion interface** despite full backend support
- **Complex information architecture** with 28 overlapping JavaScript modules
- **Mirrored content** between main panels and transparency modals

The backend is fully functional with comprehensive APIs. The redesign focuses on **frontend simplification and UX optimization**.

## Current State Analysis

### ✅ Backend Capabilities (Fully Implemented)
- **28+ API endpoints** including complete Wikipedia import (`/api/knowledge/import/wikipedia`)
- **Real-time WebSocket streaming** for cognitive events
- **Complete knowledge management** (search, categorization, export)
- **Full GödelOS integration** with cognitive transparency
- **File upload, URL import, text import, batch processing**

### ❌ Frontend Issues Identified
1. **HTML Duplication**: Lines 918-1467 contain identical transparency panel code
2. **Wikipedia UI Disconnect**: Backend API exists, frontend exists, but buried in complex tabs
3. **Module Fragmentation**: 28 JavaScript files with overlapping responsibilities
4. **Content Mirroring**: Same visualizations appear in multiple places
5. **Complex Navigation**: User confusion due to information architecture

## New Design Philosophy

### Core Principles
1. **Progressive Disclosure**: Show complexity only when needed
2. **Unified Interface**: Single coherent experience, not fragmented panels
3. **Context-Aware Transparency**: Cognitive insights appear contextually
4. **Simplified Knowledge Flow**: One-step import for all sources
5. **Cognitive Fidelity**: Interface accurately reflects actual cognitive processes
6. **Collaborative Intelligence**: Position user as cognitive partner, not passive observer
7. **Living Knowledge**: Present knowledge as dynamic, evolving networks
8. **Manifest Consciousness Navigation**: Use attention focus as primary interface metaphor

### Architectural Understanding Integration

Based on deep analysis of the GödelOS cognitive architecture, the interface must support:

#### **Three-Layer Cognitive Architecture**
- **Manifest Consciousness**: Foreground attention, deliberate reasoning, explicit reflection
- **Agentic Processes**: Independent cognitive agents pursuing parallel subtasks and hypotheses
- **Daemon Threads**: Background learning, memory consolidation, pattern discovery

#### **Cognitive Process Types**
- **Multi-level Reflection**: Recursive self-analysis (reflection → meta-reflection → meta-meta-reflection)
- **Analogical Reasoning**: Deep structural similarity discovery across domains
- **Conceptual Blending**: Novel concept creation through domain fusion
- **Hypothesis Generation**: Automatic theory creation for unexplained phenomena
- **Knowledge Integration**: Continuous synthesis of heterogeneous information sources

#### **Intelligence Capabilities**
- **Transparent Reasoning**: Every conclusion traceable through symbolic logic
- **Creative Problem-Solving**: Generation of novel solutions through analogical reasoning
- **Self-Modification**: Dynamic architecture evolution and strategy optimization
- **Uncertainty Management**: Explicit confidence tracking and gap identification
- **Knowledge Synthesis**: Integration across Wikipedia, academic papers, conversations, structured data

### Information Architecture Redesign

```
GödelOS Interface
├── Primary Query Interface (always visible)
├── Response Panel (contextual transparency)
├── Cognitive State Monitor (live system awareness)
├── Knowledge Management (on-demand)
│   ├── Quick Import (prominent)
│   ├── Search & Browse (secondary)
│   └── Management Tools (tertiary)
└── System Evolution Dashboard (self-modification & capability tracking)
    ├── Capability Assessment (what the system can/cannot do)
    ├── Learning Progress (how abilities are evolving)
    ├── Self-Modification Proposals (system-suggested improvements)
    └── Architecture Health (cognitive performance metrics)
```

## Detailed Design Specifications

### 1. Unified Query Interface

**Current**: Complex layout with separate panels
**New**: Single, focused query interface with progressive disclosure

```html
<div class="godelos-unified-interface">
  <header class="query-header">
    <div class="query-input-group">
      <input type="text" class="primary-query" placeholder="Ask GödelOS anything...">
      <button class="query-submit">Ask</button>
    </div>
    <div class="query-modes">
      <button class="mode-btn active" data-mode="reasoning">🧠 Reasoning</button>
      <button class="mode-btn" data-mode="factual">📚 Factual</button>
      <button class="mode-btn" data-mode="creative">✨ Creative</button>
    </div>
  </header>
  
  <main class="response-area">
    <div class="primary-response">
      <!-- Main answer -->
    </div>
    <aside class="process-insight" data-state="collapsed">
      <!-- Contextual transparency -->
    </aside>
  </main>
  
  <footer class="knowledge-toolbar">
    <div class="quick-actions">
      <button class="action-btn" data-action="upload">📁 Add Knowledge</button>
      <button class="action-btn" data-action="search">🔍 Search</button>
      <button class="action-btn" data-action="manage">⚙️ Manage</button>
    </div>
  </footer>
</div>
```

### 2. Contextual Transparency System

**Problem**: Duplicate transparency panels confuse users
**Solution**: Single transparency system that appears contextually

#### Design Pattern: Expandable Process Insight
```
┌─────────────────────────────────────────────┐
│ Response: "John is likely at the office"    │
│ Confidence: 85% ████████▓▓                  │
│                                             │
│ [▼] Show reasoning (3 steps)                │  ← Collapsed by default
├─────────────────────────────────────────────┤
│ 💡 Used 4 knowledge sources                 │  ← Contextual hints
│ ⚠️  Some uncertainty about current time     │
└─────────────────────────────────────────────┘

When expanded:
┌─────────────────────────────────────────────┐
│ Response: "John is likely at the office"    │
│ Confidence: 85% ████████▓▓                  │
│                                             │
│ [▲] Reasoning Chain:                        │
│   1. 📍 John works at TechCorp              │  ← Step-by-step
│   2. 🕐 Current time is 2:30 PM             │     with sources
│   3. 💼 Office hours are 9 AM - 6 PM        │
│                                             │
│ 🕸️ Knowledge Used:                          │  ← Relevant context
│   • Employment record (confidence: 95%)     │     only
│   • Schedule data (confidence: 80%)         │
│   • Location rules (confidence: 90%)        │
│                                             │
│ ⚠️  Uncertainty Factors:                    │
│   • Last location update: 1 hour ago        │
│   • No direct confirmation of presence      │
└─────────────────────────────────────────────┘
```

### 3. Streamlined Knowledge Import

**Problem**: Wikipedia import buried in complex interface
**Solution**: Prominent, smart import system

#### Smart Import Detection
```
┌─────────────────────────────────────────────┐
│ 📁 Add Knowledge to GödelOS                 │
├─────────────────────────────────────────────┤
│ [Paste URL or text, or drag files here]     │  ← Single input
│                                             │     auto-detects
│ 🔍 Auto-detected: Wikipedia article         │     source type
│     "Artificial Intelligence"               │
│                                             │
│ Options: [✓] Include references             │  ← Smart defaults
│          [✓] Extract key concepts           │     for detected
│          [ ] Technical details only         │     content type
│                                             │
│ [Import to GödelOS] [Cancel]                │
└─────────────────────────────────────────────┘

Progress (when importing):
┌─────────────────────────────────────────────┐
│ 📥 Importing: Artificial Intelligence       │
│ ████████████▓▓▓▓▓▓▓▓  60%                   │
│                                             │
│ ✓ Downloaded article (2.4MB)               │
│ ✓ Extracted 847 concepts                   │
│ ⏳ Processing relationships...              │
│                                             │
│ 💡 Found 23 related articles               │
│    Import these too? [Yes] [No]            │
└─────────────────────────────────────────────┘
```

### 4. Simplified Module Architecture

**Current**: 28 JavaScript modules with overlapping responsibilities
**New**: 6 focused modules with clear separation

```javascript
// New Module Structure
src/scripts/
├── core.js                 // Main app, event coordination
├── query-interface.js      // Query input/output, response display
├── transparency.js         // Unified cognitive transparency
├── knowledge-manager.js    // All knowledge operations (import/search/manage)
├── visualizations.js       // All visual components
└── utils.js               // Shared utilities

// Eliminated modules (functionality consolidated):
// - adaptive-interface.js -> core.js
// - cognitive-layers.js -> transparency.js  
// - knowledge-ingestion.js -> knowledge-manager.js
// - knowledge-search.js -> knowledge-manager.js
// - metacognitive-dashboard.js -> transparency.js
// - provenance-explorer.js -> transparency.js
// - reasoning-visualizer.js -> visualizations.js
// - uncertainty-visualizer.js -> visualizations.js
// + 14 other modules consolidated
```

### 5. Visual Design System

#### Color & Typography
```css
:root {
  /* Primary Colors - Cognitive Focus */
  --primary-blue: #2563eb;      /* Query/Action */
  --primary-purple: #7c3aed;    /* Reasoning */
  --primary-teal: #0d9488;      /* Knowledge */
  
  /* Semantic Colors */
  --confidence-high: #059669;   /* 80%+ confidence */
  --confidence-med: #d97706;    /* 50-80% confidence */ 
  --confidence-low: #dc2626;    /* <50% confidence */
  --uncertainty: #6366f1;       /* Uncertainty indicators */
  
  /* Interface Hierarchy */
  --text-primary: #f8fafc;      /* Main content */
  --text-secondary: #cbd5e1;    /* Supporting text */
  --text-tertiary: #64748b;     /* Meta information */
  
  /* Backgrounds */
  --bg-primary: #0f172a;        /* Main background */
  --bg-secondary: #1e293b;      /* Panel backgrounds */
  --bg-tertiary: #334155;       /* Card backgrounds */
}

/* Typography Scale */
.text-display { font-size: 2.25rem; font-weight: 700; }  /* Page title */
.text-heading { font-size: 1.5rem; font-weight: 600; }   /* Section heads */
.text-body { font-size: 1rem; font-weight: 400; }        /* Main content */
.text-caption { font-size: 0.875rem; font-weight: 400; } /* Meta info */
.text-code { font-family: 'JetBrains Mono'; }            /* Code/data */
```

## Svelte-Based Architecture Design

### Why Svelte for GödelOS

**Perfect Match for Cognitive Transparency:**
- **Reactive by Default**: Cognitive state changes automatically propagate through UI
- **No Virtual DOM Overhead**: Critical for real-time cognitive monitoring performance
- **Component-Based**: Natural fit for modular cognitive interfaces
- **Small Bundle Size**: Essential for fast cognitive transparency loading
- **Built-in State Management**: Svelte stores perfect for cognitive state tracking

### Svelte Component Architecture

```
src/
├── components/
│   ├── core/
│   │   ├── QueryInterface.svelte        // Main query input with modes
│   │   ├── ResponseDisplay.svelte       // Primary response area
│   │   └── CognitiveStateMonitor.svelte // Live cognitive transparency
│   ├── transparency/
│   │   ├── ReflectionVisualization.svelte    // Multi-level reflection
│   │   ├── ResourceAllocation.svelte         // Cognitive load display
│   │   ├── ProcessInsight.svelte             // Expandable reasoning
│   │   └── UncertaintyIndicator.svelte       // Confidence visualization
│   ├── knowledge/
│   │   ├── SmartImport.svelte           // Auto-detecting import
│   │   ├── KnowledgeGraph.svelte        // Interactive knowledge network
│   │   ├── ConceptEvolution.svelte      // Knowledge development timeline
│   │   └── SourceTracker.svelte         // Knowledge provenance
│   ├── evolution/
│   │   ├── CapabilityDashboard.svelte   // Real-time capability assessment
│   │   ├── ModificationProposals.svelte // Self-improvement suggestions
│   │   ├── ArchitectureTimeline.svelte  // System evolution history
│   │   └── CollaborativeSession.svelte  // Human-AI partnership
│   └── ui/
│       ├── Button.svelte                // Unified button component
│       ├── Card.svelte                  // Flexible card container
│       ├── ProgressBar.svelte           // Confidence/progress display
│       ├── Disclosure.svelte            // Progressive disclosure
│       └── LoadingSpinner.svelte        // Cognitive processing indicator
├── stores/
│   ├── cognitive.js                     // Cognitive state management
│   ├── knowledge.js                     // Knowledge base state
│   ├── evolution.js                     // System evolution tracking
│   └── ui.js                           // UI state and preferences
├── utils/
│   ├── websocket.js                     // WebSocket cognitive streaming
│   ├── api.js                          // Backend API integration
│   ├── formatting.js                   // Data display utilities
│   └── animations.js                   // Smooth transition helpers
└── App.svelte                          // Main application container
```

### Reactive Cognitive State Management

```javascript
// stores/cognitive.js - Svelte store for real-time cognitive state
import { writable, derived } from 'svelte/store';

// Core cognitive state
export const cognitiveState = writable({
  manifestConsciousness: {
    attention: null,
    workingMemory: [],
    processingLoad: 0
  },
  agenticProcesses: [],
  daemonThreads: [],
  systemHealth: {
    inferenceEngine: 0,
    knowledgeStore: 0,
    reflectionEngine: 0,
    learningModules: 0
  },
  alerts: []
});

// Derived stores for specific UI components
export const attentionFocus = derived(
  cognitiveState,
  $state => $state.manifestConsciousness.attention
);

export const processingLoad = derived(
  cognitiveState,
  $state => $state.manifestConsciousness.processingLoad
);

export const activeAgents = derived(
  cognitiveState,
  $state => $state.agenticProcesses.filter(agent => agent.status === 'active')
);

// WebSocket integration for real-time updates
export function initCognitiveStream() {
  const ws = new WebSocket('ws://localhost:8000/ws/cognitive_state');
  
  ws.onmessage = (event) => {
    const update = JSON.parse(event.data);
    cognitiveState.update(state => ({
      ...state,
      ...update
    }));
  };
  
  return ws;
}
```

### Svelte Component Examples

#### 1. Real-Time Cognitive State Monitor

```svelte
<!-- components/core/CognitiveStateMonitor.svelte -->
<script>
  import { cognitiveState, attentionFocus, activeAgents } from '../../stores/cognitive.js';
  import { slide } from 'svelte/transition';
  import { quintOut } from 'svelte/easing';
  
  export let expanded = false;
  
  $: manifestConsciousness = $cognitiveState.manifestConsciousness;
  $: daemonThreads = $cognitiveState.daemonThreads;
  $: systemHealth = $cognitiveState.systemHealth;
</script>

<div class="cognitive-monitor" class:expanded>
  <button 
    class="monitor-toggle"
    on:click={() => expanded = !expanded}
  >
    📊 Live Cognitive State
    <span class="toggle-icon" class:rotated={expanded}>▼</span>
  </button>
  
  {#if expanded}
    <div class="monitor-content" transition:slide={{ duration: 300, easing: quintOut }}>
      <!-- Manifest Consciousness -->
      <section class="consciousness-section">
        <h3>🧠 Manifest Consciousness</h3>
        <div class="attention-display">
          <span class="label">🎯 Attention:</span>
          <span class="value">{$attentionFocus || 'Idle'}</span>
        </div>
        <div class="working-memory">
          <span class="label">🧮 Working Memory:</span>
          <span class="value">
            {manifestConsciousness.workingMemory.length}/12 slots occupied
          </span>
        </div>
        <div class="processing-load">
          <span class="label">⚡ Processing Load:</span>
          <div class="progress-bar">
            <div 
              class="progress-fill" 
              style="width: {manifestConsciousness.processingLoad}%"
            ></div>
          </div>
          <span class="percentage">{manifestConsciousness.processingLoad}%</span>
        </div>
      </section>
      
      <!-- Agentic Processes -->
      <section class="agents-section">
        <h3>🤖 Agentic Processes ({$activeAgents.length} active)</h3>
        {#each $activeAgents as agent (agent.id)}
          <div class="agent-item" transition:slide>
            <span class="agent-name">{agent.name}</span>
            <span class="agent-task">{agent.currentTask}</span>
            <span class="agent-domain">[{agent.domain}]</span>
          </div>
        {/each}
      </section>
      
      <!-- Daemon Threads -->
      <section class="daemons-section">
        <h3>🔄 Daemon Threads ({daemonThreads.length} running)</h3>
        {#each daemonThreads as daemon (daemon.id)}
          <div class="daemon-item">
            <span class="daemon-icon">{daemon.icon}</span>
            <span class="daemon-name">{daemon.name}</span>
            <span class="daemon-status" class:active={daemon.status === 'active'}>
              {daemon.status}
            </span>
          </div>
        {/each}
      </section>
      
      <!-- System Health -->
      <section class="health-section">
        <h3>💚 System Health</h3>
        {#each Object.entries(systemHealth) as [component, health]}
          <div class="health-item">
            <span class="component-name">{component}:</span>
            <div class="health-bar">
              <div 
                class="health-fill" 
                class:healthy={health >= 80}
                class:warning={health >= 60 && health < 80}
                class:critical={health < 60}
                style="width: {health}%"
              ></div>
            </div>
            <span class="health-percentage">{health}% healthy</span>
          </div>
        {/each}
      </section>
    </div>
  {/if}
</div>

<style>
  .cognitive-monitor {
    background: var(--bg-secondary);
    border-radius: 0.5rem;
    border: 1px solid rgba(255,255,255,0.1);
    margin: 1rem 0;
  }
  
  .monitor-toggle {
    width: 100%;
    padding: 0.75rem;
    background: transparent;
    border: none;
    color: var(--text-primary);
    font-size: 1rem;
    font-weight: 600;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: space-between;
  }
  
  .toggle-icon {
    transition: transform 0.2s ease;
  }
  
  .toggle-icon.rotated {
    transform: rotate(180deg);
  }
  
  .monitor-content {
    padding: 0 0.75rem 0.75rem;
  }
  
  .consciousness-section,
  .agents-section,
  .daemons-section,
  .health-section {
    margin-bottom: 1rem;
    padding: 0.75rem;
    background: var(--bg-tertiary);
    border-radius: 0.375rem;
  }
  
  .consciousness-section h3,
  .agents-section h3,
  .daemons-section h3,
  .health-section h3 {
    margin: 0 0 0.5rem 0;
    color: var(--text-primary);
    font-size: 0.875rem;
  }
  
  .attention-display,
  .working-memory {
    display: flex;
    justify-content: space-between;
    margin-bottom: 0.5rem;
    font-size: 0.875rem;
  }
  
  .processing-load {
    display: flex;
    align-items: center;
    gap: 0.5rem;
    font-size: 0.875rem;
  }
  
  .progress-bar {
    flex: 1;
    height: 0.5rem;
    background: rgba(255,255,255,0.1);
    border-radius: 0.25rem;
    overflow: hidden;
  }
  
  .progress-fill {
    height: 100%;
    background: var(--primary-blue);
    transition: width 0.3s ease;
  }
  
  .agent-item,
  .daemon-item {
    display: flex;
    align-items: center;
    gap: 0.5rem;
    padding: 0.25rem 0;
    font-size: 0.875rem;
    color: var(--text-secondary);
  }
  
  .daemon-status.active {
    color: var(--confidence-high);
  }
  
  .health-item {
    display: flex;
    align-items: center;
    gap: 0.5rem;
    margin-bottom: 0.25rem;
    font-size: 0.875rem;
  }
  
  .health-bar {
    flex: 1;
    height: 0.375rem;
    background: rgba(255,255,255,0.1);
    border-radius: 0.25rem;
    overflow: hidden;
  }
  
  .health-fill {
    height: 100%;
    transition: width 0.3s ease;
  }
  
  .health-fill.healthy {
    background: var(--confidence-high);
  }
  
  .health-fill.warning {
    background: var(--confidence-med);
  }
  
  .health-fill.critical {
    background: var(--confidence-low);
  }
</style>
```

#### 2. Smart Knowledge Import Component

```svelte
<!-- components/knowledge/SmartImport.svelte -->
<script>
  import { createEventDispatcher } from 'svelte';
  import { knowledgeStore } from '../../stores/knowledge.js';
  import { fade, scale } from 'svelte/transition';
  
  const dispatch = createEventDispatcher();
  
  let dragActive = false;
  let inputValue = '';
  let detectedType = null;
  let importOptions = {
    includeReferences: true,
    extractConcepts: true,
    technicalOnly: false
  };
  let importing = false;
  let importProgress = 0;
  
  // Auto-detect content type
  $: {
    if (inputValue) {
      detectedType = detectContentType(inputValue);
    } else {
      detectedType = null;
    }
  }
  
  function detectContentType(input) {
    if (input.includes('wikipedia.org')) {
      return { type: 'wikipedia', title: extractWikipediaTitle(input) };
    } else if (input.includes('arxiv.org')) {
      return { type: 'academic', title: 'Academic Paper' };
    } else if (input.startsWith('http')) {
      return { type: 'webpage', title: 'Web Page' };
    } else if (input.length > 100) {
      return { type: 'text', title: 'Text Content' };
    }
    return null;
  }
  
  function extractWikipediaTitle(url) {
    const match = url.match(/\/wiki\/([^#?]+)/);
    return match ? decodeURIComponent(match[1]).replace(/_/g, ' ') : 'Wikipedia Article';
  }
  
  function handleDrop(event) {
    event.preventDefault();
    dragActive = false;
    
    const files = Array.from(event.dataTransfer.files);
    if (files.length > 0) {
      handleFileImport(files[0]);
    }
  }
  
  function handleDragOver(event) {
    event.preventDefault();
    dragActive = true;
  }
  
  function handleDragLeave() {
    dragActive = false;
  }
  
  async function handleImport() {
    if (!inputValue && !detectedType) return;
    
    importing = true;
    importProgress = 0;
    
    try {
      const response = await fetch('/api/knowledge/import', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          source: inputValue,
          type: detectedType?.type,
          options: importOptions
        })
      });
      
      if (response.ok) {
        const result = await response.json();
        knowledgeStore.update(store => ({
          ...store,
          items: [...store.items, result]
        }));
        
        dispatch('imported', result);
        inputValue = '';
        importProgress = 100;
        
        setTimeout(() => {
          importing = false;
          importProgress = 0;
        }, 1000);
      }
    } catch (error) {
      console.error('Import failed:', error);
      importing = false;
    }
  }
</script>

<div class="smart-import">
  <div 
    class="import-area"
    class:drag-active={dragActive}
    on:drop={handleDrop}
    on:dragover={handleDragOver}
    on:dragleave={handleDragLeave}
  >
    <textarea
      bind:value={inputValue}
      placeholder="Paste URL or text, or drag files here"
      class="import-input"
      rows="3"
    ></textarea>
    
    {#if detectedType}
      <div class="detection-result" transition:fade>
        <span class="detection-icon">🔍</span>
        <span class="detection-text">
          Auto-detected: {detectedType.type} 
          <strong>"{detectedType.title}"</strong>
        </span>
      </div>
    {/if}
    
    {#if detectedType}
      <div class="import-options" transition:scale>
        <label>
          <input type="checkbox" bind:checked={importOptions.includeReferences}>
          Include references
        </label>
        <label>
          <input type="checkbox" bind:checked={importOptions.extractConcepts}>
          Extract key concepts
        </label>
        <label>
          <input type="checkbox" bind:checked={importOptions.technicalOnly}>
          Technical details only
        </label>
      </div>
    {/if}
    
    <div class="import-actions">
      <button 
        class="btn btn-primary"
        disabled={!inputValue || importing}
        on:click={handleImport}
      >
        {importing ? 'Importing...' : 'Import to GödelOS'}
      </button>
      
      {#if inputValue}
        <button 
          class="btn btn-ghost"
          on:click={() => inputValue = ''}
        >
          Cancel
        </button>
      {/if}
    </div>
    
    {#if importing}
      <div class="import-progress" transition:fade>
        <div class="progress-bar">
          <div 
            class="progress-fill" 
            style="width: {importProgress}%"
          ></div>
        </div>
        <div class="progress-text">
          Processing knowledge and extracting concepts...
        </div>
      </div>
    {/if}
  </div>
</div>

<style>
  .smart-import {
    background: var(--bg-secondary);
    border-radius: 0.5rem;
    padding: 1rem;
    border: 1px solid rgba(255,255,255,0.1);
  }
  
  .import-area {
    position: relative;
  }
  
  .import-area.drag-active {
    border: 2px dashed var(--primary-blue);
    background: rgba(37, 99, 235, 0.1);
  }
  
  .import-input {
    width: 100%;
    min-height: 4rem;
    padding: 0.75rem;
    background: var(--bg-tertiary);
    border: 1px solid rgba(255,255,255,0.1);
    border-radius: 0.375rem;
    color: var(--text-primary);
    font-family: inherit;
    resize: vertical;
  }
  
  .import-input:focus {
    outline: none;
    border-color: var(--primary-blue);
  }
  
  .detection-result {
    margin: 0.75rem 0;
    padding: 0.5rem;
    background: rgba(13, 148, 136, 0.1);
    border: 1px solid var(--primary-teal);
    border-radius: 0.375rem;
    display: flex;
    align-items: center;
    gap: 0.5rem;
    font-size: 0.875rem;
  }
  
  .import-options {
    display: flex;
    gap: 1rem;
    margin: 0.75rem 0;
    font-size: 0.875rem;
  }
  
  .import-options label {
    display: flex;
    align-items: center;
    gap: 0.25rem;
    color: var(--text-secondary);
  }
  
  .import-actions {
    display: flex;
    gap: 0.5rem;
    margin-top: 0.75rem;
  }
  
  .import-progress {
    margin-top: 0.75rem;
  }
  
  .progress-bar {
    height: 0.5rem;
    background: rgba(255,255,255,0.1);
    border-radius: 0.25rem;
    overflow: hidden;
    margin-bottom: 0.5rem;
  }
  
  .progress-fill {
    height: 100%;
    background: var(--primary-teal);
    transition: width 0.3s ease;
  }
  
  .progress-text {
    font-size: 0.875rem;
    color: var(--text-secondary);
  }
</style>
```

### Comprehensive Svelte Architecture

#### Core Store Architecture
```javascript
// stores/cognitive.js - Primary cognitive state management
import { writable, derived, readable } from 'svelte/store';
import { browser } from '$app/environment';

// Primary cognitive state store
export const cognitiveState = writable({
  manifestConsciousness: {
    attention: null,
    workingMemory: { slots: 0, capacity: 12 },
    processingLoad: 0
  },
  agenticProcesses: [],
  daemonThreads: [],
  systemHealth: {
    inferenceEngine: 0,
    knowledgeStore: 0,
    reflectionEngine: 0,
    learningModules: 0
  },
  alerts: []
});

// Real-time WebSocket connection store
export const wsConnection = readable(null, (set) => {
  if (!browser) return;
  
  const ws = new WebSocket('ws://localhost:8080/api/cognitive/stream');
  
  ws.onopen = () => {
    console.log('Cognitive state WebSocket connected');
    set(ws);
  };
  
  ws.onmessage = (event) => {
    const update = JSON.parse(event.data);
    cognitiveState.update(state => ({ ...state, ...update }));
  };
  
  ws.onclose = () => {
    console.log('Cognitive state WebSocket disconnected');
    set(null);
  };
  
  return () => ws.close();
});

// stores/evolution.js - System evolution and self-modification state
export const evolutionState = writable({
  capabilities: {},
  proposals: [],
  architectureHistory: [],
  currentVersion: '2.3.7',
  learningProgress: {},
  modificationQueue: []
});

// Derived stores for reactive UI updates
export const pendingProposals = derived(
  evolutionState,
  $state => $state.proposals.filter(p => p.status === 'pending')
);

export const capabilityTrends = derived(
  evolutionState,
  $state => {
    const trends = {};
    Object.entries($state.capabilities).forEach(([capability, data]) => {
      if (data.history && data.history.length > 1) {
        const recent = data.history.slice(-7); // Last 7 days
        const change = recent[recent.length - 1].value - recent[0].value;
        trends[capability] = {
          change,
          direction: change > 0 ? 'up' : change < 0 ? 'down' : 'stable',
          percentage: Math.abs(change)
        };
      }
    });
    return trends;
  }
);

export const systemHealthStatus = derived(
  cognitiveState,
  $state => {
    const health = $state.systemHealth;
    const average = Object.values(health).reduce((a, b) => a + b, 0) / Object.keys(health).length;
    return {
      overall: average,
      status: average >= 80 ? 'healthy' : average >= 60 ? 'warning' : 'critical',
      components: health
    };
  }
);

// stores/knowledge.js - Knowledge state with reactive graph updates
export const knowledgeStore = writable({
  items: [],
  connections: [],
  conceptEvolution: {},
  importQueue: [],
  graphLayout: null
});

export const activeKnowledgeGraph = derived(
  knowledgeStore,
  $store => {
    // Transform knowledge items into graph format for visualization
    const nodes = $store.items.map(item => ({
      id: item.id,
      label: item.title,
      group: item.type,
      level: item.confidence || 0.5
    }));
    
    const edges = $store.connections.map(conn => ({
      from: conn.source,
      to: conn.target,
      strength: conn.weight
    }));
    
    return { nodes, edges };
  }
);

// stores/reflection.js - Multi-level reflection state
export const reflectionState = writable({
  currentQuery: null,
  reflectionLevels: [],
  maxDepth: 3,
  perspectiveShifts: [],
  uncertaintyTracking: []
});

export const reflectionDepth = derived(
  reflectionState,
  $state => $state.reflectionLevels.length
);

// stores/collaboration.js - Human-AI collaboration state
export const collaborationState = writable({
  activeSessions: [],
  sharedInsights: [],
  learningPoints: [],
  cognitiveUpdates: [],
  feedbackLoop: {
    corrections: 0,
    confirmations: 0,
    newPatterns: 0
  }
});
```

#### Advanced Svelte Component Architecture

```svelte
<!-- CognitiveStateMonitor.svelte - Real-time cognitive transparency -->
<script>
  import { onMount } from 'svelte';
  import { cognitiveState, wsConnection, systemHealthStatus } from '../stores/cognitive.js';
  import { fade, slide } from 'svelte/transition';
  import { tweened } from 'svelte/motion';
  import { cubicOut } from 'svelte/easing';
  
  export let expanded = false;
  
  // Tweened values for smooth animations
  const processingLoad = tweened(0, { duration: 400, easing: cubicOut });
  const memoryUsage = tweened(0, { duration: 400, easing: cubicOut });
  
  // Reactive updates from cognitive state
  $: if ($cognitiveState.manifestConsciousness) {
    processingLoad.set($cognitiveState.manifestConsciousness.processingLoad);
    memoryUsage.set($cognitiveState.manifestConsciousness.workingMemory.slots / 12);
  }
  
  // Connection status indicator
  $: connectionStatus = $wsConnection ? 'connected' : 'disconnected';
  
  function formatAgentName(agent) {
    return agent.name.replace(/^Agent-/, '');
  }
  
  function getHealthColor(percentage) {
    if (percentage >= 80) return 'var(--success-green)';
    if (percentage >= 60) return 'var(--warning-yellow)';
    return 'var(--danger-red)';
  }
</script>

<div class="cognitive-monitor">
  <button 
    class="monitor-toggle" 
    on:click={() => expanded = !expanded}
    class:connected={connectionStatus === 'connected'}
  >
    <span class="monitor-title">
      📊 Live Cognitive State
      <span class="connection-indicator" class:connected={connectionStatus === 'connected'}>
        {connectionStatus === 'connected' ? '🟢' : '🔴'}
      </span>
    </span>
    <span class="toggle-icon" class:rotated={expanded}>▼</span>
  </button>
  
  {#if expanded}
    <div class="monitor-content" transition:slide={{ duration: 300 }}>
      <!-- Manifest Consciousness Section -->
      <section class="consciousness-section">
        <h3>🎯 Manifest Consciousness</h3>
        {#if $cognitiveState.manifestConsciousness?.attention}
          <div class="attention-display" transition:fade>
            <strong>Current Focus:</strong> {$cognitiveState.manifestConsciousness.attention}
          </div>
        {/if}
        
        <div class="metrics-grid">
          <div class="metric">
            <label>Working Memory</label>
            <div class="memory-slots">
              {#each Array(12) as _, i}
                <div 
                  class="memory-slot" 
                  class:filled={i < $cognitiveState.manifestConsciousness?.workingMemory?.slots}
                  transition:fade={{ delay: i * 50 }}
                ></div>
              {/each}
            </div>
            <span class="metric-value">
              {$cognitiveState.manifestConsciousness?.workingMemory?.slots || 0}/12
            </span>
          </div>
          
          <div class="metric">
            <label>Processing Load</label>
            <div class="progress-bar">
              <div 
                class="progress-fill" 
                style="width: {$processingLoad}%; background-color: {getHealthColor($processingLoad)}"
              ></div>
            </div>
            <span class="metric-value">{Math.round($processingLoad)}%</span>
          </div>
        </div>
      </section>
      
      <!-- Active Agents Section -->
      {#if $cognitiveState.agenticProcesses?.length > 0}
        <section class="agents-section">
          <h3>🤖 Agentic Processes ({$cognitiveState.agenticProcesses.length} active)</h3>
          <div class="agents-list">
            {#each $cognitiveState.agenticProcesses as agent (agent.id)}
              <div class="agent-item" transition:slide={{ duration: 200 }}>
                <span class="agent-name">{formatAgentName(agent)}</span>
                <span class="agent-task">{agent.currentTask}</span>
                <span class="agent-domain">[{agent.domain}]</span>
              </div>
            {/each}
          </div>
        </section>
      {/if}
      
      <!-- Daemon Threads Section -->
      {#if $cognitiveState.daemonThreads?.length > 0}
        <section class="daemons-section">
          <h3>🔄 Background Processes</h3>
          <div class="daemons-grid">
            {#each $cognitiveState.daemonThreads as daemon (daemon.name)}
              <div class="daemon-item" class:active={daemon.status === 'active'}>
                <span class="daemon-icon">{daemon.icon}</span>
                <span class="daemon-name">{daemon.name}</span>
                <span class="daemon-status status-{daemon.status}">{daemon.status}</span>
              </div>
            {/each}
          </div>
        </section>
      {/if}
      
      <!-- System Health Section -->
      <section class="health-section">
        <h3>🏥 System Health</h3>
        <div class="health-overview">
          <div class="overall-health">
            <span class="health-label">Overall:</span>
            <div class="health-bar">
              <div 
                class="health-fill" 
                style="width: {$systemHealthStatus.overall}%; background-color: {getHealthColor($systemHealthStatus.overall)}"
              ></div>
            </div>
            <span class="health-value">{Math.round($systemHealthStatus.overall)}%</span>
          </div>
        </div>
        
        <div class="components-health">
          {#each Object.entries($systemHealthStatus.components) as [component, health] (component)}
            <div class="component-health">
              <span class="component-name">{component}:</span>
              <div class="health-bar small">
                <div 
                  class="health-fill" 
                  style="width: {health}%; background-color: {getHealthColor(health)}"
                ></div>
              </div>
              <span class="health-value">{health}%</span>
            </div>
          {/each}
        </div>
      </section>
      
      <!-- Alerts Section -->
      {#if $cognitiveState.alerts?.length > 0}
        <section class="alerts-section">
          <h3>⚠️ System Alerts</h3>
          <div class="alerts-list">
            {#each $cognitiveState.alerts as alert (alert.id)}
              <div class="alert-item severity-{alert.severity}" transition:slide>
                <span class="alert-icon">⚠️</span>
                <span class="alert-message">{alert.message}</span>
                <span class="alert-time">{alert.timestamp}</span>
              </div>
            {/each}
          </div>
        </section>
      {/if}
    </div>
  {/if}
</div>

<style>
  .cognitive-monitor {
    background: var(--bg-secondary);
    border-radius: 0.5rem;
    border: 1px solid rgba(255,255,255,0.1);
    margin: 1rem 0;
    overflow: hidden;
  }
  
  .monitor-toggle {
    width: 100%;
    padding: 0.75rem;
    background: transparent;
    border: none;
    color: var(--text-primary);
    font-size: 1rem;
    font-weight: 600;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: space-between;
    transition: background-color 0.2s ease;
  }
  
  .monitor-toggle:hover {
    background: rgba(255,255,255,0.05);
  }
  
  .monitor-toggle.connected {
    border-left: 3px solid var(--success-green);
  }
  
  .monitor-title {
    display: flex;
    align-items: center;
    gap: 0.5rem;
  }
  
  .connection-indicator {
    font-size: 0.75rem;
  }
  
  .toggle-icon {
    transition: transform 0.2s ease;
  }
  
  .toggle-icon.rotated {
    transform: rotate(180deg);
  }
  
  .monitor-content {
    padding: 0 0.75rem 0.75rem;
    max-height: 80vh;
    overflow-y: auto;
  }
  
  .consciousness-section,
  .agents-section,
  .daemons-section,
  .health-section,
  .alerts-section {
    margin-bottom: 1.5rem;
    padding-bottom: 1rem;
    border-bottom: 1px solid rgba(255,255,255,0.1);
  }
  
  .consciousness-section h3,
  .agents-section h3,
  .daemons-section h3,
  .health-section h3,
  .alerts-section h3 {
    margin: 0 0 0.75rem 0;
    color: var(--text-primary);
    font-size: 0.9rem;
    font-weight: 600;
  }
  
  .attention-display {
    background: rgba(59, 130, 246, 0.1);
    border: 1px solid var(--primary-blue);
    padding: 0.5rem;
    border-radius: 0.25rem;
    margin-bottom: 0.75rem;
    font-size: 0.85rem;
  }
  
  .metrics-grid {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 1rem;
  }
  
  .metric {
    display: flex;
    flex-direction: column;
    gap: 0.25rem;
  }
  
  .metric label {
    font-size: 0.8rem;
    color: var(--text-secondary);
    font-weight: 500;
  }
  
  .memory-slots {
    display: flex;
    gap: 2px;
    margin: 0.25rem 0;
  }
  
  .memory-slot {
    width: 8px;
    height: 8px;
    background: rgba(255,255,255,0.2);
    border-radius: 2px;
    transition: background-color 0.3s ease;
  }
  
  .memory-slot.filled {
    background: var(--primary-teal);
  }
  
  .progress-bar {
    height: 8px;
    background: rgba(255,255,255,0.1);
    border-radius: 4px;
    overflow: hidden;
    margin: 0.25rem 0;
  }
  
  .progress-fill {
    height: 100%;
    background: var(--primary-teal);
    transition: width 0.4s cubic-bezier(0.25, 0.46, 0.45, 0.94);
  }
  
  .metric-value {
    font-size: 0.8rem;
    color: var(--text-secondary);
    text-align: center;
  }
  
  .agents-list {
    display: flex;
    flex-direction: column;
    gap: 0.5rem;
  }
  
  .agent-item {
    display: flex;
    align-items: center;
    gap: 0.5rem;
    padding: 0.5rem;
    background: rgba(255,255,255,0.05);
    border-radius: 0.25rem;
    font-size: 0.85rem;
  }
  
  .agent-name {
    font-weight: 600;
    color: var(--primary-blue);
  }
  
  .agent-task {
    flex: 1;
    color: var(--text-primary);
  }
  
  .agent-domain {
    color: var(--text-secondary);
    font-style: italic;
  }
  
  .daemons-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
    gap: 0.5rem;
  }
  
  .daemon-item {
    display: flex;
    align-items: center;
    gap: 0.5rem;
    padding: 0.5rem;
    background: rgba(255,255,255,0.05);
    border-radius: 0.25rem;
    font-size: 0.85rem;
    opacity: 0.7;
    transition: opacity 0.2s ease;
  }
  
  .daemon-item.active {
    opacity: 1;
    border-left: 2px solid var(--primary-teal);
  }
  
  .daemon-icon {
    font-size: 1rem;
  }
  
  .daemon-name {
    flex: 1;
    color: var(--text-primary);
  }
  
  .daemon-status {
    font-size: 0.75rem;
    padding: 0.1rem 0.3rem;
    border-radius: 0.15rem;
    text-transform: uppercase;
    font-weight: 600;
  }
  
  .status-active {
    background: rgba(34, 197, 94, 0.2);
    color: var(--success-green);
  }
  
  .status-idle {
    background: rgba(156, 163, 175, 0.2);
    color: var(--text-secondary);
  }
  
  .status-scheduled {
    background: rgba(251, 191, 36, 0.2);
    color: var(--warning-yellow);
  }
  
  .health-overview {
    margin-bottom: 0.75rem;
  }
  
  .overall-health {
    display: flex;
    align-items: center;
    gap: 0.5rem;
    font-size: 0.9rem;
  }
  
  .health-label {
    color: var(--text-secondary);
    min-width: 60px;
  }
  
  .health-bar {
    flex: 1;
    height: 12px;
    background: rgba(255,255,255,0.1);
    border-radius: 6px;
    overflow: hidden;
  }
  
  .health-bar.small {
    height: 8px;
    border-radius: 4px;
  }
  
  .health-fill {
    height: 100%;
    transition: width 0.4s ease, background-color 0.3s ease;
  }
  
  .health-value {
    min-width: 40px;
    text-align: right;
    color: var(--text-secondary);
    font-size: 0.85rem;
  }
  
  .components-health {
    display: flex;
    flex-direction: column;
    gap: 0.5rem;
  }
  
  .component-health {
    display: flex;
    align-items: center;
    gap: 0.5rem;
    font-size: 0.85rem;
  }
  
  .component-name {
    color: var(--text-secondary);
    min-width: 120px;
  }
  
  .alerts-list {
    display: flex;
    flex-direction: column;
    gap: 0.5rem;
  }
  
  .alert-item {
    display: flex;
    align-items: center;
    gap: 0.5rem;
    padding: 0.5rem;
    border-radius: 0.25rem;
    font-size: 0.85rem;
  }
  
  .severity-low {
    background: rgba(251, 191, 36, 0.1);
    border: 1px solid var(--warning-yellow);
  }
  
  .severity-medium {
    background: rgba(249, 115, 22, 0.1);
    border: 1px solid #f97316;
  }
  
  .severity-high {
    background: rgba(239, 68, 68, 0.1);
    border: 1px solid var(--danger-red);
  }
  
  .alert-icon {
    font-size: 1rem;
  }
  
  .alert-message {
    flex: 1;
    color: var(--text-primary);
  }
  
  .alert-time {
    color: var(--text-secondary);
    font-size: 0.75rem;
  }
</style>

#### Self-Modification Interface Components

```svelte
<!-- SystemEvolutionDashboard.svelte - System evolution and capability tracking -->
<script>
  import { onMount, onDestroy } from 'svelte';
  import { evolutionState, pendingProposals, capabilityTrends } from '../stores/evolution.js';
  import { fade, fly, scale } from 'svelte/transition';
  import { quintOut } from 'svelte/easing';
  import CapabilityProgress from './CapabilityProgress.svelte';
  import ProposalCard from './ProposalCard.svelte';
  import ArchitectureTimeline from './ArchitectureTimeline.svelte';
  
  export let activeTab = 'capabilities';
  
  let autoRefreshInterval;
  
  onMount(() => {
    // Auto-refresh capability data every 30 seconds
    autoRefreshInterval = setInterval(refreshCapabilities, 30000);
  });
  
  onDestroy(() => {
    if (autoRefreshInterval) clearInterval(autoRefreshInterval);
  });
  
  async function refreshCapabilities() {
    try {
      const response = await fetch('/api/cognitive/capabilities');
      const capabilities = await response.json();
      evolutionState.update(state => ({ ...state, capabilities }));
    } catch (error) {
      console.error('Failed to refresh capabilities:', error);
    }
  }
  
  async function approveProposal(proposalId) {
    try {
      await fetch(`/api/modifications/proposals/${proposalId}/approve`, {
        method: 'POST'
      });
      evolutionState.update(state => ({
        ...state,
        proposals: state.proposals.map(p => 
          p.id === proposalId ? { ...p, status: 'approved' } : p
        )
      }));
    } catch (error) {
      console.error('Failed to approve proposal:', error);
    }
  }
  
  async function declineProposal(proposalId) {
    try {
      await fetch(`/api/modifications/proposals/${proposalId}/decline`, {
        method: 'POST'
      });
      evolutionState.update(state => ({
        ...state,
        proposals: state.proposals.filter(p => p.id !== proposalId)
      }));
    } catch (error) {
      console.error('Failed to decline proposal:', error);
    }
  }
  
  function formatImpact(impact) {
    if (impact > 0) return `+${impact}%`;
    return `${impact}%`;
  }
  
  function getRiskColor(riskLevel) {
    switch (riskLevel.toLowerCase()) {
      case 'low': return 'var(--success-green)';
      case 'medium': return 'var(--warning-yellow)';
      case 'high': return 'var(--danger-red)';
      default: return 'var(--text-secondary)';
    }
  }
</script>

<div class="evolution-dashboard">
  <header class="dashboard-header">
    <h2>🧠 System Evolution & Self-Modification</h2>
    <div class="version-info">
      <span class="version-label">Current Version:</span>
      <span class="version-number">{$evolutionState.currentVersion}</span>
    </div>
  </header>
  
  <nav class="dashboard-tabs">
    <button 
      class="tab-button"
      class:active={activeTab === 'capabilities'}
      on:click={() => activeTab = 'capabilities'}
    >
      🎯 Capabilities
    </button>
    <button 
      class="tab-button"
      class:active={activeTab === 'proposals'}
      on:click={() => activeTab = 'proposals'}
    >
      🔧 Proposals ({$pendingProposals.length})
    </button>
    <button 
      class="tab-button"
      class:active={activeTab === 'timeline'}
      on:click={() => activeTab = 'timeline'}
    >
      📈 Evolution Timeline
    </button>
  </nav>
  
  <main class="dashboard-content">
    {#if activeTab === 'capabilities'}
      <div class="capabilities-view" transition:fade={{ duration: 200 }}>
        <section class="capability-overview">
          <h3>Current Cognitive Capabilities</h3>
          <div class="capabilities-grid">
            {#each Object.entries($evolutionState.capabilities) as [name, data] (name)}
              <div class="capability-card" transition:fly={{ y: 20, duration: 300, delay: 100 }}>
                <CapabilityProgress 
                  {name}
                  value={data.current}
                  trend={$capabilityTrends[name]}
                  description={data.description}
                />
              </div>
            {/each}
          </div>
        </section>
        
        <section class="learning-focus">
          <h3>🎯 Active Learning Focus Areas</h3>
          <div class="focus-areas">
            {#each $evolutionState.learningProgress?.focusAreas || [] as area (area.id)}
              <div class="focus-area" transition:scale={{ duration: 200 }}>
                <span class="area-name">{area.name}</span>
                <div class="progress-indicator">
                  <div class="progress-bar">
                    <div 
                      class="progress-fill" 
                      style="width: {area.progress}%"
                    ></div>
                  </div>
                  <span class="progress-text">{area.progress}%</span>
                </div>
                <span class="area-priority priority-{area.priority}">{area.priority}</span>
              </div>
            {/each}
          </div>
        </section>
      </div>
    {/if}
    
    {#if activeTab === 'proposals'}
      <div class="proposals-view" transition:fade={{ duration: 200 }}>
        <section class="proposals-header">
          <h3>🔧 System Improvement Proposals</h3>
          <button class="propose-button">
            + Propose Custom Modification
          </button>
        </section>
        
        {#if $pendingProposals.length > 0}
          <div class="proposals-list">
            {#each $pendingProposals as proposal (proposal.id)}
              <div class="proposal-card" transition:fly={{ x: -20, duration: 300 }}>
                <ProposalCard 
                  {proposal}
                  on:approve={() => approveProposal(proposal.id)}
                  on:decline={() => declineProposal(proposal.id)}
                />
              </div>
            {/each}
          </div>
        {:else}
          <div class="no-proposals" transition:fade>
            <p>No pending proposals. System is running optimally.</p>
          </div>
        {/if}
        
        <section class="implementation-history">
          <h3>📊 Recent Implementation History</h3>
          <div class="history-list">
            {#each $evolutionState.proposals?.filter(p => p.status !== 'pending') || [] as proposal (proposal.id)}
              <div class="history-item status-{proposal.status}">
                <span class="history-title">{proposal.title}</span>
                <span class="history-status">{proposal.status}</span>
                <span class="history-date">{new Date(proposal.implementedAt).toLocaleDateString()}</span>
              </div>
            {/each}
          </div>
        </section>
      </div>
    {/if}
    
    {#if activeTab === 'timeline'}
      <div class="timeline-view" transition:fade={{ duration: 200 }}>
        <ArchitectureTimeline 
          history={$evolutionState.architectureHistory}
          currentVersion={$evolutionState.currentVersion}
        />
      </div>
    {/if}
  </main>
</div>

<style>
  .evolution-dashboard {
    background: var(--bg-primary);
    border-radius: 0.5rem;
    overflow: hidden;
    border: 1px solid rgba(255,255,255,0.1);
  }
  
  .dashboard-header {
    padding: 1rem 1.5rem;
    background: var(--bg-secondary);
    border-bottom: 1px solid rgba(255,255,255,0.1);
    display: flex;
    justify-content: space-between;
    align-items: center;
  }
  
  .dashboard-header h2 {
    margin: 0;
    color: var(--text-primary);
    font-size: 1.25rem;
    font-weight: 600;
  }
  
  .version-info {
    display: flex;
    align-items: center;
    gap: 0.5rem;
    font-size: 0.9rem;
  }
  
  .version-label {
    color: var(--text-secondary);
  }
  
  .version-number {
    color: var(--primary-teal);
    font-weight: 600;
    font-family: monospace;
  }
  
  .dashboard-tabs {
    display: flex;
    background: var(--bg-secondary);
    border-bottom: 1px solid rgba(255,255,255,0.1);
  }
  
  .tab-button {
    flex: 1;
    padding: 0.75rem 1rem;
    background: transparent;
    border: none;
    color: var(--text-secondary);
    cursor: pointer;
    font-size: 0.9rem;
    font-weight: 500;
    transition: all 0.2s ease;
    border-bottom: 2px solid transparent;
  }
  
  .tab-button:hover {
    background: rgba(255,255,255,0.05);
    color: var(--text-primary);
  }
  
  .tab-button.active {
    color: var(--primary-teal);
    border-bottom-color: var(--primary-teal);
    background: rgba(13, 148, 136, 0.1);
  }
  
  .dashboard-content {
    padding: 1.5rem;
    min-height: 400px;
  }
  
  .capability-overview h3,
  .learning-focus h3,
  .proposals-header h3,
  .implementation-history h3 {
    margin: 0 0 1rem 0;
    color: var(--text-primary);
    font-size: 1.1rem;
    font-weight: 600;
  }
  
  .capabilities-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
    gap: 1rem;
    margin-bottom: 2rem;
  }
  
  .capability-card {
    background: var(--bg-secondary);
    border-radius: 0.375rem;
    padding: 1rem;
    border: 1px solid rgba(255,255,255,0.1);
  }
  
  .focus-areas {
    display: flex;
    flex-direction: column;
    gap: 0.75rem;
  }
  
  .focus-area {
    display: flex;
    align-items: center;
    gap: 1rem;
    padding: 0.75rem;
    background: var(--bg-secondary);
    border-radius: 0.375rem;
    border: 1px solid rgba(255,255,255,0.1);
  }
  
  .area-name {
    flex: 1;
    color: var(--text-primary);
    font-weight: 500;
  }
  
  .progress-indicator {
    display: flex;
    align-items: center;
    gap: 0.5rem;
    min-width: 120px;
  }
  
  .progress-bar {
    width: 80px;
    height: 8px;
    background: rgba(255,255,255,0.1);
    border-radius: 4px;
    overflow: hidden;
  }
  
  .progress-fill {
    height: 100%;
    background: var(--primary-teal);
    transition: width 0.3s ease;
  }
  
  .progress-text {
    font-size: 0.8rem;
    color: var(--text-secondary);
  }
  
  .area-priority {
    padding: 0.2rem 0.5rem;
    border-radius: 0.25rem;
    font-size: 0.8rem;
    font-weight: 600;
    text-transform: uppercase;
  }
  
  .priority-high {
    background: rgba(239, 68, 68, 0.2);
    color: var(--danger-red);
  }
  
  .priority-medium {
    background: rgba(251, 191, 36, 0.2);
    color: var(--warning-yellow);
  }
  
  .priority-low {
    background: rgba(34, 197, 94, 0.2);
    color: var(--success-green);
  }
  
  .proposals-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 1.5rem;
  }
  
  .propose-button {
    padding: 0.5rem 1rem;
    background: var(--primary-teal);
    color: white;
    border: none;
    border-radius: 0.375rem;
    cursor: pointer;
    font-weight: 500;
    transition: background-color 0.2s ease;
  }
  
  .propose-button:hover {
    background: #0f766e;
  }
  
  .proposals-list {
    display: flex;
    flex-direction: column;
    gap: 1rem;
    margin-bottom: 2rem;
  }
  
  .proposal-card {
    background: var(--bg-secondary);
    border-radius: 0.5rem;
    border: 1px solid rgba(255,255,255,0.1);
  }
  
  .no-proposals {
    text-align: center;
    padding: 2rem;
    color: var(--text-secondary);
    background: var(--bg-secondary);
    border-radius: 0.5rem;
    border: 1px solid rgba(255,255,255,0.1);
  }
  
  .history-list {
    display: flex;
    flex-direction: column;
    gap: 0.5rem;
  }
  
  .history-item {
    display: flex;
    align-items: center;
    gap: 1rem;
    padding: 0.75rem;
    background: var(--bg-secondary);
    border-radius: 0.375rem;
    border: 1px solid rgba(255,255,255,0.1);
  }
  
  .history-title {
    flex: 1;
    color: var(--text-primary);
  }
  
  .history-status {
    padding: 0.2rem 0.5rem;
    border-radius: 0.25rem;
    font-size: 0.8rem;
    font-weight: 600;
    text-transform: uppercase;
  }
  
  .status-approved .history-status {
    background: rgba(34, 197, 94, 0.2);
    color: var(--success-green);
  }
  
  .status-declined .history-status {
    background: rgba(239, 68, 68, 0.2);
    color: var(--danger-red);
  }
  
  .status-testing .history-status {
    background: rgba(251, 191, 36, 0.2);
    color: var(--warning-yellow);
  }
  
  .history-date {
    color: var(--text-secondary);
    font-size: 0.85rem;
  }
</style>
```

#### Collaborative Intelligence Components

```svelte
<!-- CollaborativeReasoningSession.svelte - Human-AI cognitive partnership -->
<script>
  import { onMount, createEventDispatcher } from 'svelte';
  import { collaborationState } from '../stores/collaboration.js';
  import { fade, fly, scale } from 'svelte/transition';
  import { writable } from 'svelte/store';
  
  const dispatch = createEventDispatcher();
  
  export let sessionId = null;
  export let topic = '';
  
  let currentSession = null;
  let humanInput = '';
  let sessionActive = false;
  let contributions = [];
  let sharedInsights = [];
  
  const inputFocused = writable(false);
  
  onMount(() => {
    if (sessionId) {
      loadSession(sessionId);
    }
  });
  
  async function startSession() {
    try {
      const response = await fetch('/api/collaboration/sessions', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ topic })
      });
      
      if (response.ok) {
        currentSession = await response.json();
        sessionActive = true;
        sessionId = currentSession.id;
        
        collaborationState.update(state => ({
          ...state,
          activeSessions: [...state.activeSessions, currentSession]
        }));
        
        dispatch('sessionStarted', currentSession);
      }
    } catch (error) {
      console.error('Failed to start session:', error);
    }
  }
  
  async function addHumanContribution() {
    if (!humanInput.trim() || !sessionActive) return;
    
    const contribution = {
      type: 'human',
      content: humanInput.trim(),
      timestamp: new Date().toISOString()
    };
    
    try {
      const response = await fetch(`/api/collaboration/sessions/${sessionId}/contribute`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(contribution)
      });
      
      if (response.ok) {
        const result = await response.json();
        contributions = [...contributions, contribution];
        
        // Add AI response if generated
        if (result.aiResponse) {
          contributions = [...contributions, {
            type: 'ai',
            content: result.aiResponse,
            timestamp: new Date().toISOString(),
            confidence: result.confidence,
            reasoning: result.reasoning
          }];
        }
        
        // Update shared insights
        if (result.newInsights) {
          sharedInsights = [...sharedInsights, ...result.newInsights];
        }
        
        humanInput = '';
      }
    } catch (error) {
      console.error('Failed to add contribution:', error);
    }
  }
  
  async function endSession() {
    if (!sessionActive) return;
    
    try {
      const response = await fetch(`/api/collaboration/sessions/${sessionId}/end`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ 
          summary: generateSessionSummary(),
          insights: sharedInsights 
        })
      });
      
      if (response.ok) {
        sessionActive = false;
        dispatch('sessionEnded', { 
          sessionId, 
          summary: generateSessionSummary(),
          insights: sharedInsights 
        });
      }
    } catch (error) {
      console.error('Failed to end session:', error);
    }
  }
  
  function generateSessionSummary() {
    const humanContributions = contributions.filter(c => c.type === 'human').length;
    const aiContributions = contributions.filter(c => c.type === 'ai').length;
    
    return {
      topic,
      duration: currentSession ? Date.now() - new Date(currentSession.startedAt).getTime() : 0,
      humanContributions,
      aiContributions,
      insightsGenerated: sharedInsights.length,
      totalExchanges: contributions.length
    };
  }
  
  function handleKeydown(event) {
    if (event.key === 'Enter' && (event.metaKey || event.ctrlKey)) {
      addHumanContribution();
    }
  }
</script>

<div class="collaboration-session">
  <header class="session-header">
    <h3>🤝 Collaborative Reasoning Session</h3>
    {#if sessionActive}
      <div class="session-status">
        <span class="status-indicator active"></span>
        <span class="status-text">Active Session</span>
        <button class="end-session-btn" on:click={endSession}>
          End Session
        </button>
      </div>
    {/if}
  </header>
  
  {#if !sessionActive}
    <div class="session-setup" transition:fade>
      <div class="setup-form">
        <label for="topic-input">Session Topic:</label>
        <input 
          id="topic-input"
          bind:value={topic} 
          placeholder="Enter the topic for collaborative analysis..."
          class="topic-input"
        />
        <button 
          class="start-session-btn" 
          on:click={startSession}
          disabled={!topic.trim()}
        >
          Start Collaborative Session
        </button>
      </div>
    </div>
  {:else}
    <div class="session-content" transition:fade>
      <div class="topic-display">
        <strong>Topic:</strong> {topic}
      </div>
      
      <div class="contributions-area">
        <div class="contributions-list" id="contributions-scroll">
          {#each contributions as contribution, index (index)}
            <div 
              class="contribution contribution-{contribution.type}"
              transition:fly={{ y: 20, duration: 300, delay: index * 50 }}
            >
              <div class="contribution-header">
                <span class="contributor-icon">
                  {contribution.type === 'human' ? '👤' : '🤖'}
                </span>
                <span class="contributor-type">
                  {contribution.type === 'human' ? 'Human' : 'GödelOS'}
                </span>
                {#if contribution.confidence}
                  <span class="confidence-indicator">
                    Confidence: {Math.round(contribution.confidence * 100)}%
                  </span>
                {/if}
                <span class="contribution-time">
                  {new Date(contribution.timestamp).toLocaleTimeString()}
                </span>
              </div>
              
              <div class="contribution-content">
                {contribution.content}
              </div>
              
              {#if contribution.reasoning}
                <div class="ai-reasoning">
                  <details>
                    <summary>View Reasoning Process</summary>
                    <div class="reasoning-content">
                      {contribution.reasoning}
                    </div>
                  </details>
                </div>
              {/if}
            </div>
          {/each}
        </div>
        
        <div class="input-area">
          <textarea
            bind:value={humanInput}
            placeholder="Share your thoughts, insights, or questions..."
            class="human-input"
            class:focused={$inputFocused}
            on:focus={() => inputFocused.set(true)}
            on:blur={() => inputFocused.set(false)}
            on:keydown={handleKeydown}
            rows="3"
          ></textarea>
          
          <div class="input-controls">
            <span class="input-hint">⌘+Enter to send</span>
            <button 
              class="send-btn"
              on:click={addHumanContribution}
              disabled={!humanInput.trim()}
            >
              Send
            </button>
          </div>
        </div>
      </div>
      
      {#if sharedInsights.length > 0}
        <div class="insights-panel" transition:scale>
          <h4>🎯 Collaborative Insights</h4>
          <div class="insights-list">
            {#each sharedInsights as insight, index (index)}
              <div 
                class="insight-item"
                transition:fly={{ x: -20, duration: 200, delay: index * 100 }}
              >
                <span class="insight-icon">💡</span>
                <span class="insight-text">{insight.text}</span>
                <span class="insight-source">
                  ({insight.source === 'collaborative' ? 'Joint Discovery' : insight.source})
                </span>
              </div>
            {/each}
          </div>
        </div>
      {/if}
    </div>
  {/if}
</div>

<style>
  .collaboration-session {
    background: var(--bg-secondary);
    border-radius: 0.5rem;
    border: 1px solid rgba(255,255,255,0.1);
    overflow: hidden;
  }
  
  .session-header {
    padding: 1rem 1.5rem;
    background: var(--bg-tertiary);
    border-bottom: 1px solid rgba(255,255,255,0.1);
    display: flex;
    justify-content: space-between;
    align-items: center;
  }
  
  .session-header h3 {
    margin: 0;
    color: var(--text-primary);
    font-size: 1.1rem;
    font-weight: 600;
  }
  
  .session-status {
    display: flex;
    align-items: center;
    gap: 0.75rem;
  }
  
  .status-indicator {
    width: 8px;
    height: 8px;
    border-radius: 50%;
    background: var(--text-secondary);
  }
  
  .status-indicator.active {
    background: var(--success-green);
    animation: pulse 2s infinite;
  }
  
  @keyframes pulse {
    0%, 100% { opacity: 1; }
    50% { opacity: 0.5; }
  }
  
  .status-text {
    color: var(--text-secondary);
    font-size: 0.9rem;
  }
  
  .end-session-btn {
    padding: 0.375rem 0.75rem;
    background: var(--danger-red);
    color: white;
    border: none;
    border-radius: 0.25rem;
    cursor: pointer;
    font-size: 0.85rem;
    font-weight: 500;
    transition: background-color 0.2s ease;
  }
  
  .end-session-btn:hover {
    background: #dc2626;
  }
  
  .session-setup {
    padding: 2rem;
    text-align: center;
  }
  
  .setup-form {
    max-width: 500px;
    margin: 0 auto;
    display: flex;
    flex-direction: column;
    gap: 1rem;
  }
  
  .setup-form label {
    color: var(--text-primary);
    font-weight: 500;
    text-align: left;
  }
  
  .topic-input {
    width: 100%;
    padding: 0.75rem;
    background: var(--bg-primary);
    border: 1px solid rgba(255,255,255,0.2);
    border-radius: 0.375rem;
    color: var(--text-primary);
    font-size: 1rem;
  }
  
  .topic-input:focus {
    outline: none;
    border-color: var(--primary-teal);
  }
  
  .start-session-btn {
    padding: 0.75rem 1.5rem;
    background: var(--primary-teal);
    color: white;
    border: none;
    border-radius: 0.375rem;
    cursor: pointer;
    font-weight: 600;
    font-size: 1rem;
    transition: background-color 0.2s ease;
  }
  
  .start-session-btn:hover:not(:disabled) {
    background: #0f766e;
  }
  
  .start-session-btn:disabled {
    opacity: 0.5;
    cursor: not-allowed;
  }
  
  .session-content {
    padding: 1.5rem;
  }
  
  .topic-display {
    background: rgba(59, 130, 246, 0.1);
    border: 1px solid var(--primary-blue);
    padding: 0.75rem;
    border-radius: 0.375rem;
    margin-bottom: 1.5rem;
    color: var(--text-primary);
  }
  
  .contributions-area {
    display: flex;
    flex-direction: column;
    gap: 1rem;
    margin-bottom: 1.5rem;
  }
  
  .contributions-list {
    max-height: 400px;
    overflow-y: auto;
    display: flex;
    flex-direction: column;
    gap: 1rem;
    padding-right: 0.5rem;
  }
  
  .contribution {
    background: var(--bg-primary);
    border-radius: 0.5rem;
    padding: 1rem;
    border: 1px solid rgba(255,255,255,0.1);
  }
  
  .contribution-human {
    border-left: 3px solid var(--primary-blue);
  }
  
  .contribution-ai {
    border-left: 3px solid var(--primary-teal);
  }
  
  .contribution-header {
    display: flex;
    align-items: center;
    gap: 0.75rem;
    margin-bottom: 0.75rem;
    font-size: 0.85rem;
  }
  
  .contributor-icon {
    font-size: 1.1rem;
  }
  
  .contributor-type {
    font-weight: 600;
    color: var(--text-primary);
  }
  
  .confidence-indicator {
    background: rgba(34, 197, 94, 0.2);
    color: var(--success-green);
    padding: 0.1rem 0.4rem;
    border-radius: 0.25rem;
    font-size: 0.75rem;
    font-weight: 600;
  }
  
  .contribution-time {
    color: var(--text-secondary);
    margin-left: auto;
  }
  
  .contribution-content {
    color: var(--text-primary);
    line-height: 1.5;
    white-space: pre-wrap;
  }
  
  .ai-reasoning {
    margin-top: 0.75rem;
  }
  
  .ai-reasoning details {
    border: 1px solid rgba(255,255,255,0.1);
    border-radius: 0.25rem;
  }
  
  .ai-reasoning summary {
    padding: 0.5rem;
    cursor: pointer;
    color: var(--text-secondary);
    font-size: 0.85rem;
  }
  
  .ai-reasoning summary:hover {
    color: var(--text-primary);
  }
  
  .reasoning-content {
    padding: 0.75rem;
    background: var(--bg-tertiary);
    border-top: 1px solid rgba(255,255,255,0.1);
    color: var(--text-secondary);
    font-size: 0.85rem;
    line-height: 1.4;
  }
  
  .input-area {
    background: var(--bg-primary);
    border-radius: 0.5rem;
    border: 1px solid rgba(255,255,255,0.1);
    overflow: hidden;
  }
  
  .human-input {
    width: 100%;
    padding: 1rem;
    background: transparent;
    border: none;
    color: var(--text-primary);
    font-family: inherit;
    font-size: 0.95rem;
    resize: none;
    outline: none;
  }
  
  .human-input.focused {
    border-color: var(--primary-teal);
  }
  
  .input-controls {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 0.75rem 1rem;
    background: var(--bg-tertiary);
    border-top: 1px solid rgba(255,255,255,0.1);
  }
  
  .input-hint {
    color: var(--text-secondary);
    font-size: 0.8rem;
  }
  
  .send-btn {
    padding: 0.5rem 1rem;
    background: var(--primary-teal);
    color: white;
    border: none;
    border-radius: 0.25rem;
    cursor: pointer;
    font-weight: 500;
    transition: background-color 0.2s ease;
  }
  
  .send-btn:hover:not(:disabled) {
    background: #0f766e;
  }
  
  .send-btn:disabled {
    opacity: 0.5;
    cursor: not-allowed;
  }
  
  .insights-panel {
    background: rgba(139, 92, 246, 0.1);
    border: 1px solid rgba(139, 92, 246, 0.3);
    border-radius: 0.5rem;
    padding: 1rem;
    margin-top: 1rem;
  }
  
  .insights-panel h4 {
    margin: 0 0 0.75rem 0;
    color: var(--text-primary);
    font-size: 1rem;
    font-weight: 600;
  }
  
  .insights-list {
    display: flex;
    flex-direction: column;
    gap: 0.5rem;
  }
  
  .insight-item {
    display: flex;
    align-items: center;
    gap: 0.75rem;
    padding: 0.5rem;
    background: rgba(255,255,255,0.05);
    border-radius: 0.25rem;
    font-size: 0.9rem;
  }
  
  .insight-icon {
    font-size: 1rem;
  }
  
  .insight-text {
    flex: 1;
    color: var(--text-primary);
  }
  
  .insight-source {
    color: var(--text-secondary);
    font-style: italic;
    font-size: 0.8rem;
  }
</style>
```

#### Smart Knowledge Import Component

```svelte
<!-- SmartKnowledgeImport.svelte - Enhanced knowledge import with cognitive analysis -->
<script>
  import { createEventDispatcher } from 'svelte';
  import { knowledgeStore } from '../stores/knowledge.js';
  import { fade, scale, fly } from 'svelte/transition';
  import { tweened } from 'svelte/motion';
  import { cubicOut } from 'svelte/easing';
  
  const dispatch = createEventDispatcher();
  
  let dragActive = false;
  let inputValue = '';
  let detectedType = null;
  let importOptions = {
    includeReferences: true,
    extractConcepts: true,
    technicalOnly: false,
    cognitiveAnalysis: true,
    autoConnect: true
  };
  let importing = false;
  let importStage = '';
  let cognitiveInsights = [];
  let conceptsExtracted = [];
  let connectionsSuggested = [];
  
  const importProgress = tweened(0, { duration: 400, easing: cubicOut });
  
  // Auto-detect content type with enhanced analysis
  $: {
    if (inputValue) {
      detectedType = detectContentType(inputValue);
    } else {
      detectedType = null;
    }
  }
  
  function detectContentType(input) {
    const trimmed = input.trim();
    
    if (trimmed.includes('wikipedia.org')) {
      return { 
        type: 'wikipedia', 
        title: extractWikipediaTitle(trimmed),
        icon: '📚',
        description: 'Wikipedia article with structured knowledge'
      };
    } else if (trimmed.includes('arxiv.org') || trimmed.includes('doi.org')) {
      return { 
        type: 'academic', 
        title: 'Academic Paper',
        icon: '🎓',
        description: 'Research paper with citations and methodology'
      };
    } else if (trimmed.startsWith('http')) {
      return { 
        type: 'webpage', 
        title: 'Web Page',
        icon: '🌐',
        description: 'Web content with potential knowledge extraction'
      };
    } else if (trimmed.length > 500) {
      return { 
        type: 'longtext', 
        title: 'Long Text Content',
        icon: '📄',
        description: 'Extended text requiring deep analysis'
      };
    } else if (trimmed.length > 50) {
      return { 
        type: 'text', 
        title: 'Text Content',
        icon: '📝',
        description: 'Short text content for quick processing'
      };
    }
    return null;
  }
  
  function extractWikipediaTitle(url) {
    const match = url.match(/\/wiki\/([^#?]+)/);
    return match ? decodeURIComponent(match[1]).replace(/_/g, ' ') : 'Wikipedia Article';
  }
  
  function handleDrop(event) {
    event.preventDefault();
    dragActive = false;
    
    const files = Array.from(event.dataTransfer.files);
    if (files.length > 0) {
      handleFileImport(files[0]);
    }
  }
  
  function handleDragOver(event) {
    event.preventDefault();
    dragActive = true;
  }
  
  function handleDragLeave() {
    dragActive = false;
  }
  
  async function handleFileImport(file) {
    const formData = new FormData();
    formData.append('file', file);
    formData.append('options', JSON.stringify(importOptions));
    
    importing = true;
    importStage = 'Reading file...';
    importProgress.set(10);
    
    try {
      const response = await fetch('/api/knowledge/import/file', {
        method: 'POST',
        body: formData
      });
      
      if (response.ok) {
        const result = await response.json();
        await processImportResult(result);
      }
    } catch (error) {
      console.error('File import failed:', error);
      importing = false;
    }
  }
  
  async function handleImport() {
    if (!inputValue.trim() || !detectedType) return;
    
    importing = true;
    importStage = 'Analyzing content...';
    importProgress.set(0);
    cognitiveInsights = [];
    conceptsExtracted = [];
    connectionsSuggested = [];
    
    try {
      const response = await fetch('/api/knowledge/import', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          source: inputValue,
          type: detectedType.type,
          options: importOptions
        })
      });
      
      const reader = response.body.getReader();
      const decoder = new TextDecoder();
      
      while (true) {
        const { done, value } = await reader.read();
        if (done) break;
        
        const chunk = decoder.decode(value);
        const lines = chunk.split('\n').filter(line => line.trim());
        
        for (const line of lines) {
          try {
            const update = JSON.parse(line);
            await processImportUpdate(update);
          } catch (e) {
            // Skip invalid JSON lines
          }
        }
      }
      
      await finishImport();
      
    } catch (error) {
      console.error('Import failed:', error);
      importing = false;
    }
  }
  
  async function processImportUpdate(update) {
    switch (update.type) {
      case 'progress':
        importProgress.set(update.progress);
        importStage = update.stage;
        break;
        
      case 'cognitive_insight':
        cognitiveInsights = [...cognitiveInsights, update.insight];
        break;
        
      case 'concept_extracted':
        conceptsExtracted = [...conceptsExtracted, update.concept];
        break;
        
      case 'connection_suggested':
        connectionsSuggested = [...connectionsSuggested, update.connection];
        break;
    }
  }
  
  async function finishImport() {
    importProgress.set(100);
    importStage = 'Import complete';
    
    // Update knowledge store
    knowledgeStore.update(store => ({
      ...store,
      items: [...store.items, {
        id: Date.now().toString(),
        source: inputValue,
        type: detectedType.type,
        concepts: conceptsExtracted,
        insights: cognitiveInsights,
        suggestedConnections: connectionsSuggested,
        timestamp: new Date().toISOString()
      }]
    }));
    
    dispatch('imported', {
      concepts: conceptsExtracted,
      insights: cognitiveInsights,
      connections: connectionsSuggested
    });
    
    setTimeout(() => {
      importing = false;
      inputValue = '';
      cognitiveInsights = [];
      conceptsExtracted = [];
      connectionsSuggested = [];
      importProgress.set(0);
    }, 2000);
  }
</script>

<div class="smart-import">
  <header class="import-header">
    <h3>🧠 Smart Knowledge Import</h3>
    <div class="import-options-toggle">
      <span class="options-label">AI Analysis:</span>
      <label class="toggle-switch">
        <input type="checkbox" bind:checked={importOptions.cognitiveAnalysis} />
        <span class="toggle-slider"></span>
      </label>
    </div>
  </header>
  
  <div class="import-content">
    <div 
      class="drop-zone"
      class:drag-active={dragActive}
      on:drop={handleDrop}
      on:dragover={handleDragOver}
      on:dragleave={handleDragLeave}
    >
      <div class="drop-zone-content">
        {#if !importing}
          <div class="input-section">
            <textarea
              bind:value={inputValue}
              placeholder="Paste URL, text content, or drag & drop files here..."
              class="import-input"
              rows="4"
            ></textarea>
            
            {#if detectedType}
              <div class="detection-result" transition:scale>
                <span class="detection-icon">{detectedType.icon}</span>
                <div class="detection-info">
                  <span class="detection-title">{detectedType.title}</span>
                  <span class="detection-description">{detectedType.description}</span>
                </div>
              </div>
            {/if}
          </div>
          
          <div class="import-options">
            <label>
              <input type="checkbox" bind:checked={importOptions.includeReferences} />
              Include references
            </label>
            <label>
              <input type="checkbox" bind:checked={importOptions.extractConcepts} />
              Extract concepts
            </label>
            <label>
              <input type="checkbox" bind:checked={importOptions.autoConnect} />
              Auto-connect to existing knowledge
            </label>
          </div>
          
          <div class="import-actions">
            <button 
              class="import-btn"
              on:click={handleImport}
              disabled={!inputValue.trim() || !detectedType}
            >
              <span class="btn-icon">🚀</span>
              Start Smart Import
            </button>
          </div>
        {:else}
          <div class="import-progress" transition:fade>
            <div class="progress-header">
              <h4>🔄 Processing Import</h4>
              <span class="progress-percentage">{Math.round($importProgress)}%</span>
            </div>
            
            <div class="progress-bar">
              <div 
                class="progress-fill" 
                style="width: {$importProgress}%"
              ></div>
            </div>
            
            <div class="progress-stage">{importStage}</div>
            
            {#if cognitiveInsights.length > 0}
              <div class="live-insights" transition:fly={{ y: 20 }}>
                <h5>💡 Cognitive Insights</h5>
                <div class="insights-stream">
                  {#each cognitiveInsights as insight, index (index)}
                    <div 
                      class="insight-item"
                      transition:fly={{ x: -20, duration: 200, delay: index * 100 }}
                    >
                      {insight}
                    </div>
                  {/each}
                </div>
              </div>
            {/if}
            
            {#if conceptsExtracted.length > 0}
              <div class="live-concepts" transition:fly={{ y: 20 }}>
                <h5>🏷️ Concepts Extracted</h5>
                <div class="concepts-stream">
                  {#each conceptsExtracted as concept, index (index)}
                    <span 
                      class="concept-tag"
                      transition:scale={{ duration: 200, delay: index * 50 }}
                    >
                      {concept}
                    </span>
                  {/each}
                </div>
              </div>
            {/if}
            
            {#if connectionsSuggested.length > 0}
              <div class="live-connections" transition:fly={{ y: 20 }}>
                <h5>🔗 Suggested Connections</h5>
                <div class="connections-stream">
                  {#each connectionsSuggested as connection, index (index)}
                    <div 
                      class="connection-item"
                      transition:fly={{ x: -20, duration: 200, delay: index * 100 }}
                    >
                      <span class="connection-from">{connection.from}</span>
                      <span class="connection-arrow">↔</span>
                      <span class="connection-to">{connection.to}</span>
                      <span class="connection-strength">({connection.strength})</span>
                    </div>
                  {/each}
                </div>
              </div>
            {/if}
          </div>
        {/if}
      </div>
    </div>
  </div>
</div>

<style>
  .smart-import {
    background: var(--bg-secondary);
    border-radius: 0.5rem;
    border: 1px solid rgba(255,255,255,0.1);
    overflow: hidden;
  }
  
  .import-header {
    padding: 1rem 1.5rem;
    background: var(--bg-tertiary);
    border-bottom: 1px solid rgba(255,255,255,0.1);
    display: flex;
    justify-content: space-between;
    align-items: center;
  }
  
  .import-header h3 {
    margin: 0;
    color: var(--text-primary);
    font-size: 1.1rem;
    font-weight: 600;
  }
  
  .import-options-toggle {
    display: flex;
    align-items: center;
    gap: 0.5rem;
  }
  
  .options-label {
    color: var(--text-secondary);
    font-size: 0.9rem;
  }
  
  .toggle-switch {
    position: relative;
    display: inline-block;
    width: 44px;
    height: 24px;
  }
  
  .toggle-switch input {
    opacity: 0;
    width: 0;
    height: 0;
  }
  
  .toggle-slider {
    position: absolute;
    cursor: pointer;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background-color: rgba(255,255,255,0.2);
    transition: 0.3s;
    border-radius: 24px;
  }
  
  .toggle-slider:before {
    position: absolute;
    content: "";
    height: 18px;
    width: 18px;
    left: 3px;
    bottom: 3px;
    background-color: white;
    transition: 0.3s;
    border-radius: 50%;
  }
  
  input:checked + .toggle-slider {
    background-color: var(--primary-teal);
  }
  
  input:checked + .toggle-slider:before {
    transform: translateX(20px);
  }
  
  .import-content {
    padding: 1.5rem;
  }
  
  .drop-zone {
    border: 2px dashed rgba(255,255,255,0.2);
    border-radius: 0.5rem;
    padding: 1.5rem;
    transition: all 0.3s ease;
    min-height: 200px;
  }
  
  .drop-zone.drag-active {
    border-color: var(--primary-teal);
    background: rgba(13, 148, 136, 0.1);
  }
  
  .input-section {
    margin-bottom: 1rem;
  }
  
  .import-input {
    width: 100%;
    padding: 0.75rem;
    background: var(--bg-primary);
    border: 1px solid rgba(255,255,255,0.1);
    border-radius: 0.375rem;
    color: var(--text-primary);
    font-family: inherit;
    resize: vertical;
    font-size: 0.95rem;
  }
  
  .import-input:focus {
    outline: none;
    border-color: var(--primary-teal);
  }
  
  .detection-result {
    margin-top: 0.75rem;
    padding: 0.75rem;
    background: rgba(13, 148, 136, 0.1);
    border: 1px solid var(--primary-teal);
    border-radius: 0.375rem;
    display: flex;
    align-items: center;
    gap: 0.75rem;
  }
  
  .detection-icon {
    font-size: 1.5rem;
  }
  
  .detection-info {
    display: flex;
    flex-direction: column;
    gap: 0.25rem;
  }
  
  .detection-title {
    color: var(--text-primary);
    font-weight: 600;
  }
  
  .detection-description {
    color: var(--text-secondary);
    font-size: 0.85rem;
  }
  
  .import-options {
    display: flex;
    flex-wrap: wrap;
    gap: 1rem;
    margin-bottom: 1rem;
    font-size: 0.9rem;
  }
  
  .import-options label {
    display: flex;
    align-items: center;
    gap: 0.5rem;
    color: var(--text-secondary);
    cursor: pointer;
  }
  
  .import-options input[type="checkbox"] {
    accent-color: var(--primary-teal);
  }
  
  .import-actions {
    display: flex;
    justify-content: center;
  }
  
  .import-btn {
    padding: 0.75rem 1.5rem;
    background: var(--primary-teal);
    color: white;
    border: none;
    border-radius: 0.375rem;
    cursor: pointer;
    font-weight: 600;
    font-size: 1rem;
    display: flex;
    align-items: center;
    gap: 0.5rem;
    transition: background-color 0.2s ease;
  }
  
  .import-btn:hover:not(:disabled) {
    background: #0f766e;
  }
  
  .import-btn:disabled {
    opacity: 0.5;
    cursor: not-allowed;
  }
  
  .btn-icon {
    font-size: 1.1rem;
  }
  
  .import-progress {
    text-align: center;
  }
  
  .progress-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 1rem;
  }
  
  .progress-header h4 {
    margin: 0;
    color: var(--text-primary);
    font-size: 1.1rem;
  }
  
  .progress-percentage {
    color: var(--primary-teal);
    font-weight: 600;
    font-family: monospace;
  }
  
  .progress-bar {
    height: 12px;
    background: rgba(255,255,255,0.1);
    border-radius: 6px;
    overflow: hidden;
    margin-bottom: 0.75rem;
  }
  
  .progress-fill {
    height: 100%;
    background: linear-gradient(90deg, var(--primary-teal), var(--primary-blue));
    transition: width 0.4s ease;
  }
  
  .progress-stage {
    color: var(--text-secondary);
    font-size: 0.9rem;
    margin-bottom: 1.5rem;
  }
  
  .live-insights,
  .live-concepts,
  .live-connections {
    margin: 1rem 0;
    padding: 1rem;
    background: rgba(255,255,255,0.05);
    border-radius: 0.375rem;
    text-align: left;
  }
  
  .live-insights h5,
  .live-concepts h5,
  .live-connections h5 {
    margin: 0 0 0.75rem 0;
    color: var(--text-primary);
    font-size: 0.95rem;
    font-weight: 600;
  }
  
  .insights-stream {
    display: flex;
    flex-direction: column;
    gap: 0.5rem;
  }
  
  .insight-item {
    padding: 0.5rem;
    background: rgba(59, 130, 246, 0.1);
    border-left: 2px solid var(--primary-blue);
    border-radius: 0.25rem;
    color: var(--text-primary);
    font-size: 0.85rem;
  }
  
  .concepts-stream {
    display: flex;
    flex-wrap: wrap;
    gap: 0.5rem;
  }
  
  .concept-tag {
    padding: 0.25rem 0.5rem;
    background: var(--primary-teal);
    color: white;
    border-radius: 1rem;
    font-size: 0.8rem;
    font-weight: 500;
  }
  
  .connections-stream {
    display: flex;
    flex-direction: column;
    gap: 0.5rem;
  }
  
  .connection-item {
    display: flex;
    align-items: center;
    gap: 0.5rem;
    padding: 0.5rem;
    background: rgba(139, 92, 246, 0.1);
    border-radius: 0.25rem;
    font-size: 0.85rem;
  }
  
  .connection-from,
  .connection-to {
    color: var(--text-primary);
    font-weight: 500;
  }
  
  .connection-arrow {
    color: var(--primary-purple);
    font-weight: bold;
  }
  
  .connection-strength {
    color: var(--text-secondary);
    font-size: 0.8rem;
  }
</style>
```
        };
      }
    });
    return trends;
  }
);

// WebSocket integration for evolution events
export function initEvolutionStream() {
  const ws = new WebSocket('ws://localhost:8000/ws/evolution_events');
  
  ws.onmessage = (event) => {
    const update = JSON.parse(event.data);
    
    switch(update.type) {
      case 'capability_updated':
        evolutionState.update(state => ({
          ...state,
          capabilities: {
            ...state.capabilities,
            [update.capability]: update.data
          }
        }));
        break;
        
      case 'proposal_generated':
        evolutionState.update(state => ({
          ...state,
          proposals: [...state.proposals, update.proposal]
        }));
        break;
        
      case 'architecture_evolved':
        evolutionState.update(state => ({
          ...state,
          architectureHistory: [...state.architectureHistory, update.event],
          currentVersion: update.newVersion
        }));
        break;
    }
  };
  
  return ws;
}
```

### ReflectionVisualizer.svelte

```svelte
<script>
  import { onMount, createEventDispatcher } from 'svelte';
  import { cognitiveState, reflectionHistory, systemCapabilities } from '../stores/cognitiveStore.js';
  import { fade, fly, scale } from 'svelte/transition';
  import { cubicOut } from 'svelte/easing';

  const dispatch = createEventDispatcher();

  // Component state
  let selectedReflection = null;
  let viewMode = 'timeline'; // 'timeline', 'graph', 'insights'
  let timeRange = '24h';
  let reflectionDepth = 'surface'; // 'surface', 'deep', 'meta'
  let isAnalyzing = false;
  let searchQuery = '';
  let filteredReflections = [];
  let insightPatterns = [];
  let cognitiveGraph = { nodes: [], links: [] };

  // Reactive declarations
  $: filteredReflections = filterReflections($reflectionHistory, searchQuery, timeRange, reflectionDepth);
  $: insightPatterns = extractInsightPatterns(filteredReflections);
  $: cognitiveGraph = buildCognitiveGraph(filteredReflections);

  onMount(() => {
    // Initialize reflection analysis
    analyzeReflectionPatterns();
  });

  function filterReflections(reflections, query, timeRange, depth) {
    const now = Date.now();
    const timeMs = {
      '1h': 60 * 60 * 1000,
      '6h': 6 * 60 * 60 * 1000,
      '24h': 24 * 60 * 60 * 1000,
      '7d': 7 * 24 * 60 * 60 * 1000,
      '30d': 30 * 24 * 60 * 60 * 1000
    }[timeRange];

    return reflections.filter(reflection => {
      const timeMatch = now - reflection.timestamp <= timeMs;
      const depthMatch = depth === 'surface' || reflection.depth >= {
        'surface': 1,
        'deep': 2,
        'meta': 3
      }[depth];
      const queryMatch = !query || 
        reflection.content.toLowerCase().includes(query.toLowerCase()) ||
        reflection.insights.some(insight => 
          insight.toLowerCase().includes(query.toLowerCase())
        );
      
      return timeMatch && depthMatch && queryMatch;
    });
  }

  function extractInsightPatterns(reflections) {
    const patterns = new Map();
    
    reflections.forEach(reflection => {
      reflection.insights.forEach(insight => {
        const key = insight.category || 'general';
        if (!patterns.has(key)) {
          patterns.set(key, {
            category: key,
            count: 0,
            confidence: 0,
            examples: [],
            trend: 'stable'
          });
        }
        
        const pattern = patterns.get(key);
        pattern.count++;
        pattern.confidence = Math.max(pattern.confidence, insight.confidence || 0.5);
        pattern.examples.push(insight);
      });
    });

    return Array.from(patterns.values())
      .sort((a, b) => b.confidence * b.count - a.confidence * a.count)
      .slice(0, 10);
  }

  function buildCognitiveGraph(reflections) {
    const nodes = new Map();
    const links = [];

    reflections.forEach(reflection => {
      // Add reflection as node
      if (!nodes.has(reflection.id)) {
        nodes.set(reflection.id, {
          id: reflection.id,
          label: reflection.title || reflection.content.substring(0, 50) + '...',
          type: 'reflection',
          depth: reflection.depth,
          confidence: reflection.confidence,
          timestamp: reflection.timestamp
        });
      }

      // Add concepts as nodes and create links
      reflection.concepts?.forEach(concept => {
        if (!nodes.has(concept.id)) {
          nodes.set(concept.id, {
            id: concept.id,
            label: concept.name,
            type: 'concept',
            weight: concept.weight || 1
          });
        }

        links.push({
          source: reflection.id,
          target: concept.id,
          strength: concept.relevance || 0.5,
          type: 'relates_to'
        });
      });

      // Link related reflections
      reflection.related?.forEach(relatedId => {
        if (nodes.has(relatedId)) {
          links.push({
            source: reflection.id,
            target: relatedId,
            strength: 0.7,
            type: 'builds_on'
          });
        }
      });
    });

    return {
      nodes: Array.from(nodes.values()),
      links
    };
  }

  async function analyzeReflectionPatterns() {
    isAnalyzing = true;
    try {
      // Simulate pattern analysis
      await new Promise(resolve => setTimeout(resolve, 1500));
      
      // Update cognitive state with new insights
      cognitiveState.update(state => ({
        ...state,
        reflectionInsights: insightPatterns,
        lastAnalysis: Date.now()
      }));
    } catch (error) {
      console.error('Reflection analysis failed:', error);
    } finally {
      isAnalyzing = false;
    }
  }

  function selectReflection(reflection) {
    selectedReflection = reflection;
    dispatch('reflectionSelected', { reflection });
  }

  function exportReflections() {
    const exportData = {
      reflections: filteredReflections,
      insights: insightPatterns,
      metadata: {
        exportDate: new Date().toISOString(),
        timeRange,
        reflectionDepth,
        query: searchQuery
      }
    };

    const blob = new Blob([JSON.stringify(exportData, null, 2)], {
      type: 'application/json'
    });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `reflections-export-${Date.now()}.json`;
    a.click();
    URL.revokeObjectURL(url);
  }
</script>

<div class="reflection-visualizer" transition:fade={{ duration: 300 }}>
  <!-- Header Controls -->
  <div class="visualizer-header">
    <div class="header-left">
      <h2>Reflection Visualizer</h2>
      <div class="reflection-stats">
        <span class="stat">
          <span class="count">{filteredReflections.length}</span>
          <span class="label">Reflections</span>
        </span>
        <span class="stat">
          <span class="count">{insightPatterns.length}</span>
          <span class="label">Patterns</span>
        </span>
        <span class="stat">
          <span class="count">{cognitiveGraph.nodes.length}</span>
          <span class="label">Concepts</span>
        </span>
      </div>
    </div>

    <div class="header-controls">
      <div class="search-container">
        <input 
          type="text" 
          placeholder="Search reflections..."
          bind:value={searchQuery}
          class="search-input"
        />
        <button class="search-clear" on:click={() => searchQuery = ''}>×</button>
      </div>

      <div class="filter-controls">
        <select bind:value={timeRange} class="time-filter">
          <option value="1h">Last Hour</option>
          <option value="6h">Last 6 Hours</option>
          <option value="24h">Last 24 Hours</option>
          <option value="7d">Last Week</option>
          <option value="30d">Last Month</option>
        </select>

        <select bind:value={reflectionDepth} class="depth-filter">
          <option value="surface">Surface</option>
          <option value="deep">Deep</option>
          <option value="meta">Meta</option>
        </select>

        <div class="view-mode-toggle">
          <button 
            class="mode-btn" 
            class:active={viewMode === 'timeline'}
            on:click={() => viewMode = 'timeline'}
          >
            Timeline
          </button>
          <button 
            class="mode-btn" 
            class:active={viewMode === 'graph'}
            on:click={() => viewMode = 'graph'}
          >
            Graph
          </button>
          <button 
            class="mode-btn" 
            class:active={viewMode === 'insights'}
            on:click={() => viewMode = 'insights'}
          >
            Insights
          </button>
        </div>
      </div>

      <div class="action-controls">
        <button 
          class="analyze-btn"
          class:analyzing={isAnalyzing}
          on:click={analyzeReflectionPatterns}
          disabled={isAnalyzing}
        >
          {#if isAnalyzing}
            <div class="spinner"></div>
            Analyzing...
          {:else}
            Analyze Patterns
          {/if}
        </button>

        <button class="export-btn" on:click={exportReflections}>
          Export
        </button>
      </div>
    </div>
  </div>

  <!-- Main Visualization Area -->
  <div class="visualization-container">
    {#if viewMode === 'timeline'}
      <div class="timeline-view" transition:fly={{ x: -20, duration: 300 }}>
        <div class="timeline-container">
          {#each filteredReflections as reflection, index (reflection.id)}
            <div 
              class="timeline-item"
              transition:scale={{ duration: 200, delay: index * 50 }}
              on:click={() => selectReflection(reflection)}
              class:selected={selectedReflection?.id === reflection.id}
            >
              <div class="timeline-marker">
                <div class="marker-dot" style="background-color: {reflection.color || '#4f46e5'}"></div>
                <div class="marker-line"></div>
              </div>
              
              <div class="timeline-content">
                <div class="reflection-header">
                  <h4>{reflection.title || 'Untitled Reflection'}</h4>
                  <span class="timestamp">
                    {new Date(reflection.timestamp).toLocaleString()}
                  </span>
                </div>
                
                <p class="reflection-preview">
                  {reflection.content.substring(0, 150)}...
                </p>
                
                <div class="reflection-meta">
                  <span class="depth-indicator depth-{reflection.depth}">
                    Depth {reflection.depth}
                  </span>
                  <span class="confidence-indicator">
                    {Math.round((reflection.confidence || 0.5) * 100)}% confidence
                  </span>
                  {#if reflection.insights?.length > 0}
                    <span class="insights-count">
                      {reflection.insights.length} insights
                    </span>
                  {/if}
                </div>

                {#if reflection.insights?.length > 0}
                  <div class="insights-preview">
                    {#each reflection.insights.slice(0, 2) as insight}
                      <span class="insight-tag">{insight.category || insight}</span>
                    {/each}
                    {#if reflection.insights.length > 2}
                      <span class="more-insights">+{reflection.insights.length - 2} more</span>
                    {/if}
                  </div>
                {/if}
              </div>
            </div>
          {/each}
        </div>
      </div>

    {:else if viewMode === 'graph'}
      <div class="graph-view" transition:fly={{ x: 0, y: 20, duration: 300 }}>
        <div class="graph-container">
          <svg class="cognitive-graph" viewBox="0 0 800 600">
            <!-- Graph nodes -->
            {#each cognitiveGraph.nodes as node, index}
              <g class="node-group" 
                 transform="translate({100 + (index % 8) * 80}, {100 + Math.floor(index / 8) * 80})">
                <circle 
                  class="node"
                  class:reflection-node={node.type === 'reflection'}
                  class:concept-node={node.type === 'concept'}
                  r={node.type === 'reflection' ? 8 : 5}
                  on:click={() => node.type === 'reflection' && selectReflection(filteredReflections.find(r => r.id === node.id))}
                />
                <text class="node-label" x="0" y="20">{node.label.substring(0, 15)}...</text>
              </g>
            {/each}

            <!-- Graph links -->
            {#each cognitiveGraph.links as link}
              {@const sourceNode = cognitiveGraph.nodes.find(n => n.id === link.source)}
              {@const targetNode = cognitiveGraph.nodes.find(n => n.id === link.target)}
              {#if sourceNode && targetNode}
                {@const sourceIndex = cognitiveGraph.nodes.indexOf(sourceNode)}
                {@const targetIndex = cognitiveGraph.nodes.indexOf(targetNode)}
                <line 
                  class="link"
                  class:builds-on={link.type === 'builds_on'}
                  class:relates-to={link.type === 'relates_to'}
                  x1={100 + (sourceIndex % 8) * 80}
                  y1={100 + Math.floor(sourceIndex / 8) * 80}
                  x2={100 + (targetIndex % 8) * 80}
                  y2={100 + Math.floor(targetIndex / 8) * 80}
                  stroke-width={link.strength * 3}
                />
              {/if}
            {/each}
          </svg>

          <div class="graph-legend">
            <div class="legend-item">
              <div class="legend-marker reflection-node"></div>
              <span>Reflections</span>
            </div>
            <div class="legend-item">
              <div class="legend-marker concept-node"></div>
              <span>Concepts</span>
            </div>
            <div class="legend-item">
              <div class="legend-line builds-on"></div>
              <span>Builds On</span>
            </div>
            <div class="legend-item">
              <div class="legend-line relates-to"></div>
              <span>Relates To</span>
            </div>
          </div>
        </div>
      </div>

    {:else if viewMode === 'insights'}
      <div class="insights-view" transition:fly={{ x: 20, duration: 300 }}>
        <div class="insights-grid">
          {#each insightPatterns as pattern, index (pattern.category)}
            <div 
              class="insight-card"
              transition:scale={{ duration: 200, delay: index * 100 }}
            >
              <div class="insight-header">
                <h4>{pattern.category}</h4>
                <div class="insight-metrics">
                  <span class="count-badge">{pattern.count}</span>
                  <span class="confidence-bar">
                    <div class="confidence-fill" style="width: {pattern.confidence * 100}%"></div>
                  </span>
                </div>
              </div>

              <div class="insight-examples">
                {#each pattern.examples.slice(0, 3) as example}
                  <div class="example-item">
                    {typeof example === 'string' ? example : example.content || example.description}
                  </div>
                {/each}
                {#if pattern.examples.length > 3}
                  <div class="more-examples">
                    +{pattern.examples.length - 3} more examples
                  </div>
                {/if}
              </div>

              <div class="insight-trend">
                <span class="trend-indicator trend-{pattern.trend}">
                  {pattern.trend}
                </span>
              </div>
            </div>
          {/each}
        </div>
      </div>
    {/if}
  </div>

  <!-- Selected Reflection Detail Panel -->
  {#if selectedReflection}
    <div 
      class="detail-panel"
      transition:fly={{ x: 300, duration: 300, easing: cubicOut }}
    >
      <div class="detail-header">
        <h3>{selectedReflection.title || 'Reflection Details'}</h3>
        <button class="close-detail" on:click={() => selectedReflection = null}>×</button>
      </div>

      <div class="detail-content">
        <div class="reflection-metadata">
          <div class="meta-item">
            <label>Timestamp:</label>
            <span>{new Date(selectedReflection.timestamp).toLocaleString()}</span>
          </div>
          <div class="meta-item">
            <label>Depth:</label>
            <span class="depth-{selectedReflection.depth}">Level {selectedReflection.depth}</span>
          </div>
          <div class="meta-item">
            <label>Confidence:</label>
            <span>{Math.round((selectedReflection.confidence || 0.5) * 100)}%</span>
          </div>
        </div>

        <div class="reflection-content">
          <h4>Content</h4>
          <p>{selectedReflection.content}</p>
        </div>

        {#if selectedReflection.insights?.length > 0}
          <div class="reflection-insights">
            <h4>Insights</h4>
            <div class="insights-list">
              {#each selectedReflection.insights as insight}
                <div class="insight-item">
                  <span class="insight-category">{insight.category || 'General'}</span>
                  <span class="insight-content">{insight.content || insight}</span>
                </div>
              {/each}
            </div>
          </div>
        {/if}

        {#if selectedReflection.related?.length > 0}
          <div class="related-reflections">
            <h4>Related Reflections</h4>
            <div class="related-list">
              {#each selectedReflection.related as relatedId}
                {@const related = $reflectionHistory.find(r => r.id === relatedId)}
                {#if related}
                  <button 
                    class="related-item"
                    on:click={() => selectReflection(related)}
                  >
                    {related.title || related.content.substring(0, 50)}...
                  </button>
                {/if}
              {/each}
            </div>
          </div>
        {/if}
      </div>
    </div>
  {/if}
</div>

<style>
  .reflection-visualizer {
    display: flex;
    flex-direction: column;
    height: 100vh;
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    color: white;
    font-family: 'Inter', sans-serif;
  }

  .visualizer-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 1.5rem 2rem;
    background: rgba(255, 255, 255, 0.1);
    backdrop-filter: blur(20px);
    border-bottom: 1px solid rgba(255, 255, 255, 0.2);
  }

  .header-left h2 {
    margin: 0 0 0.5rem 0;
    font-size: 1.8rem;
    font-weight: 700;
  }

  .reflection-stats {
    display: flex;
    gap: 2rem;
  }

  .stat {
    display: flex;
    flex-direction: column;
    align-items: center;
  }

  .count {
    font-size: 1.5rem;
    font-weight: 700;
    color: #a7f3d0;
  }

  .label {
    font-size: 0.8rem;
    opacity: 0.8;
  }

  .header-controls {
    display: flex;
    gap: 1rem;
    align-items: center;
  }

  .search-container {
    position: relative;
  }

  .search-input {
    padding: 0.5rem 2rem 0.5rem 1rem;
    border: 1px solid rgba(255, 255, 255, 0.3);
    border-radius: 0.5rem;
    background: rgba(255, 255, 255, 0.1);
    color: white;
    backdrop-filter: blur(10px);
    width: 250px;
  }

  .search-input::placeholder {
    color: rgba(255, 255, 255, 0.6);
  }

  .search-clear {
    position: absolute;
    right: 0.5rem;
    top: 50%;
    transform: translateY(-50%);
    background: none;
    border: none;
    color: white;
    cursor: pointer;
    font-size: 1.2rem;
  }

  .filter-controls {
    display: flex;
    gap: 0.5rem;
    align-items: center;
  }

  .time-filter, .depth-filter {
    padding: 0.5rem;
    border: 1px solid rgba(255, 255, 255, 0.3);
    border-radius: 0.375rem;
    background: rgba(255, 255, 255, 0.1);
    color: white;
    backdrop-filter: blur(10px);
  }

  .view-mode-toggle {
    display: flex;
    background: rgba(255, 255, 255, 0.1);
    border-radius: 0.5rem;
    padding: 0.25rem;
  }

  .mode-btn {
    padding: 0.5rem 1rem;
    border: none;
    border-radius: 0.375rem;
    background: transparent;
    color: white;
    cursor: pointer;
    transition: all 0.2s ease;
  }

  .mode-btn.active {
    background: rgba(255, 255, 255, 0.2);
    transform: scale(1.05);
  }

  .action-controls {
    display: flex;
    gap: 0.5rem;
  }

  .analyze-btn, .export-btn {
    padding: 0.5rem 1rem;
    border: 1px solid rgba(255, 255, 255, 0.3);
    border-radius: 0.375rem;
    background: rgba(255, 255, 255, 0.1);
    color: white;
    cursor: pointer;
    transition: all 0.2s ease;
    display: flex;
    align-items: center;
    gap: 0.5rem;
  }

  .analyze-btn:hover, .export-btn:hover {
    background: rgba(255, 255, 255, 0.2);
    transform: translateY(-1px);
  }

  .analyze-btn.analyzing {
    opacity: 0.7;
    cursor: not-allowed;
  }

  .spinner {
    width: 1rem;
    height: 1rem;
    border: 2px solid rgba(255, 255, 255, 0.3);
    border-top: 2px solid white;
    border-radius: 50%;
    animation: spin 1s linear infinite;
  }

  @keyframes spin {
    0% { transform: rotate(0deg); }
    100% { transform: rotate(360deg); }
  }

  .visualization-container {
    flex: 1;
    padding: 1rem 2rem;
    overflow: auto;
    position: relative;
  }

  .timeline-view {
    height: 100%;
  }

  .timeline-container {
    max-width: 800px;
    margin: 0 auto;
  }

  .timeline-item {
    display: flex;
    margin-bottom: 2rem;
    cursor: pointer;
    transition: all 0.3s ease;
  }

  .timeline-item:hover {
    transform: translateY(-2px);
  }

  .timeline-item.selected {
    transform: scale(1.02);
    box-shadow: 0 0 20px rgba(167, 243, 208, 0.3);
  }

  .timeline-marker {
    display: flex;
    flex-direction: column;
    align-items: center;
    margin-right: 1.5rem;
  }

  .marker-dot {
    width: 1rem;
    height: 1rem;
    border-radius: 50%;
    border: 3px solid rgba(255, 255, 255, 0.3);
    flex-shrink: 0;
  }

  .marker-line {
    width: 2px;
    height: 100px;
    background: rgba(255, 255, 255, 0.2);
    margin-top: 0.5rem;
  }

  .timeline-content {
    flex: 1;
    background: rgba(255, 255, 255, 0.1);
    border-radius: 0.75rem;
    padding: 1.5rem;
    backdrop-filter: blur(10px);
    border: 1px solid rgba(255, 255, 255, 0.2);
  }

  .reflection-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 1rem;
  }

  .reflection-header h4 {
    margin: 0;
    font-size: 1.2rem;
    font-weight: 600;
  }

  .timestamp {
    font-size: 0.8rem;
    opacity: 0.7;
  }

  .reflection-preview {
    margin-bottom: 1rem;
    line-height: 1.6;
    opacity: 0.9;
  }

  .reflection-meta {
    display: flex;
    gap: 1rem;
    margin-bottom: 1rem;
    flex-wrap: wrap;
  }

  .depth-indicator, .confidence-indicator, .insights-count {
    padding: 0.25rem 0.5rem;
    border-radius: 0.375rem;
    font-size: 0.8rem;
    background: rgba(255, 255, 255, 0.2);
  }

  .depth-1 { background: rgba(34, 197, 94, 0.3); }
  .depth-2 { background: rgba(249, 115, 22, 0.3); }
  .depth-3 { background: rgba(239, 68, 68, 0.3); }

  .insights-preview {
    display: flex;
    gap: 0.5rem;
    flex-wrap: wrap;
  }

  .insight-tag {
    padding: 0.25rem 0.5rem;
    background: rgba(167, 243, 208, 0.3);
    border-radius: 0.375rem;
    font-size: 0.8rem;
  }

  .more-insights {
    padding: 0.25rem 0.5rem;
    background: rgba(255, 255, 255, 0.2);
    border-radius: 0.375rem;
    font-size: 0.8rem;
    font-style: italic;
  }

  .graph-view {
    height: 100%;
    display: flex;
    flex-direction: column;
  }

  .graph-container {
    flex: 1;
    position: relative;
  }

  .cognitive-graph {
    width: 100%;
    height: 100%;
    background: rgba(255, 255, 255, 0.05);
    border-radius: 0.75rem;
  }

  .node {
    cursor: pointer;
    transition: all 0.2s ease;
  }

  .reflection-node {
    fill: #a7f3d0;
    stroke: #059669;
    stroke-width: 2;
  }

  .concept-node {
    fill: #fbbf24;
    stroke: #d97706;
    stroke-width: 1;
  }

  .node:hover {
    transform: scale(1.2);
  }

  .node-label {
    fill: white;
    font-size: 0.7rem;
    text-anchor: middle;
    pointer-events: none;
  }

  .link {
    stroke: rgba(255, 255, 255, 0.3);
    transition: all 0.2s ease;
  }

  .link.builds-on {
    stroke: #a7f3d0;
    stroke-dasharray: 5,5;
  }

  .link.relates-to {
    stroke: #fbbf24;
  }

  .graph-legend {
    position: absolute;
    top: 1rem;
    right: 1rem;
    background: rgba(255, 255, 255, 0.1);
    padding: 1rem;
    border-radius: 0.5rem;
    backdrop-filter: blur(10px);
  }

  .legend-item {
    display: flex;
    align-items: center;
    gap: 0.5rem;
    margin-bottom: 0.5rem;
  }

  .legend-marker {
    width: 1rem;
    height: 1rem;
    border-radius: 50%;
  }

  .legend-marker.reflection-node {
    background: #a7f3d0;
  }

  .legend-marker.concept-node {
    background: #fbbf24;
  }

  .legend-line {
    width: 1.5rem;
    height: 2px;
  }

  .legend-line.builds-on {
    background: #a7f3d0;
  }

  .legend-line.relates-to {
    background: #fbbf24;
  }

  .insights-view {
    height: 100%;
  }

  .insights-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
    gap: 1.5rem;
    height: 100%;
    overflow-y: auto;
  }

  .insight-card {
    background: rgba(255, 255, 255, 0.1);
    border-radius: 0.75rem;
    padding: 1.5rem;
    backdrop-filter: blur(10px);
    border: 1px solid rgba(255, 255, 255, 0.2);
    transition: all 0.3s ease;
  }

  .insight-card:hover {
    transform: translateY(-5px);
    box-shadow: 0 10px 25px rgba(0, 0, 0, 0.2);
  }

  .insight-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 1rem;
  }

  .insight-header h4 {
    margin: 0;
    font-size: 1.1rem;
    font-weight: 600;
  }

  .insight-metrics {
    display: flex;
    align-items: center;
    gap: 0.5rem;
  }

  .count-badge {
    background: rgba(167, 243, 208, 0.3);
    color: #a7f3d0;
    padding: 0.25rem 0.5rem;
    border-radius: 0.375rem;
    font-weight: 600;
    font-size: 0.8rem;
  }

  .confidence-bar {
    width: 50px;
    height: 4px;
    background: rgba(255, 255, 255, 0.2);
    border-radius: 2px;
    overflow: hidden;
  }

  .confidence-fill {
    height: 100%;
    background: linear-gradient(90deg, #fbbf24, #a7f3d0);
    border-radius: 2px;
    transition: width 0.3s ease;
  }

  .insight-examples {
    margin-bottom: 1rem;
  }

  .example-item {
    background: rgba(255, 255, 255, 0.1);
    padding: 0.75rem;
    border-radius: 0.5rem;
    margin-bottom: 0.5rem;
    font-size: 0.9rem;
    line-height: 1.4;
  }

  .more-examples {
    font-style: italic;
    opacity: 0.7;
    font-size: 0.8rem;
  }

  .insight-trend {
    display: flex;
    justify-content: flex-end;
  }

  .trend-indicator {
    padding: 0.25rem 0.5rem;
    border-radius: 0.375rem;
    font-size: 0.8rem;
    font-weight: 500;
  }

  .trend-stable {
    background: rgba(156, 163, 175, 0.3);
    color: #d1d5db;
  }

  .trend-increasing {
    background: rgba(34, 197, 94, 0.3);
    color: #a7f3d0;
  }

  .trend-decreasing {
    background: rgba(239, 68, 68, 0.3);
    color: #fca5a5;
  }

  .detail-panel {
    position: fixed;
    top: 0;
    right: 0;
    width: 400px;
    height: 100vh;
    background: rgba(255, 255, 255, 0.15);
    backdrop-filter: blur(20px);
    border-left: 1px solid rgba(255, 255, 255, 0.2);
    padding: 2rem;
    overflow-y: auto;
    z-index: 1000;
  }

  .detail-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 2rem;
  }

  .detail-header h3 {
    margin: 0;
    font-size: 1.3rem;
    font-weight: 600;
  }

  .close-detail {
    background: none;
    border: none;
    color: white;
    font-size: 1.5rem;
    cursor: pointer;
    padding: 0.25rem;
  }

  .detail-content {
    space-y: 1.5rem;
  }

  .reflection-metadata {
    background: rgba(255, 255, 255, 0.1);
    padding: 1rem;
    border-radius: 0.5rem;
    margin-bottom: 1.5rem;
  }

  .meta-item {
    display: flex;
    justify-content: space-between;
    margin-bottom: 0.5rem;
  }

  .meta-item label {
    font-weight: 500;
    opacity: 0.8;
  }

  .reflection-content {
    margin-bottom: 1.5rem;
  }

  .reflection-content h4 {
    margin: 0 0 1rem 0;
    font-size: 1.1rem;
    font-weight: 600;
  }

  .reflection-content p {
    line-height: 1.6;
    margin: 0;
  }

  .reflection-insights {
    margin-bottom: 1.5rem;
  }

  .reflection-insights h4 {
    margin: 0 0 1rem 0;
    font-size: 1.1rem;
    font-weight: 600;
  }

  .insights-list {
    space-y: 0.5rem;
  }

  .insight-item {
    display: flex;
    flex-direction: column;
    background: rgba(255, 255, 255, 0.1);
    padding: 0.75rem;
    border-radius: 0.5rem;
    margin-bottom: 0.5rem;
  }

  .insight-category {
    font-weight: 600;
    font-size: 0.8rem;
    color: #a7f3d0;
    margin-bottom: 0.25rem;
  }

  .insight-content {
    font-size: 0.9rem;
    line-height: 1.4;
  }

  .related-reflections h4 {
    margin: 0 0 1rem 0;
    font-size: 1.1rem;
    font-weight: 600;
  }

  .related-list {
    space-y: 0.5rem;
  }

  .related-item {
    display: block;
    width: 100%;
    text-align: left;
    background: rgba(255, 255, 255, 0.1);
    border: none;
    color: white;
    padding: 0.75rem;
    border-radius: 0.5rem;
    cursor: pointer;
    transition: all 0.2s ease;
    margin-bottom: 0.5rem;
  }

  .related-item:hover {
    background: rgba(255, 255, 255, 0.2);
    transform: translateX(5px);
  }
</style>
```

### ArchitectureTimeline.svelte

```svelte
<script>
  import { onMount, createEventDispatcher } from 'svelte';
  import { systemCapabilities, architectureHistory, evolutionMetrics } from '../stores/cognitiveStore.js';
  import { fade, fly, scale, slide } from 'svelte/transition';
  import { quintOut, cubicOut } from 'svelte/easing';

  const dispatch = createEventDispatcher();

  // Component state
  let timelineData = [];
  let selectedEvent = null;
  let viewMode = 'chronological'; // 'chronological', 'impact', 'category'
  let timeRange = 'all'; // 'all', '1d', '1w', '1m', '3m', '1y'
  let filterCategory = 'all'; // 'all', 'capability', 'performance', 'integration', 'bug-fix'
  let isLoading = false;
  let searchQuery = '';
  let showMetrics = true;
  let animationSpeed = 'normal'; // 'slow', 'normal', 'fast'
  let groupByPeriod = 'day'; // 'hour', 'day', 'week', 'month'

  // Reactive declarations
  $: filteredEvents = filterTimelineEvents(timelineData, searchQuery, timeRange, filterCategory);
  $: groupedEvents = groupEventsByPeriod(filteredEvents, groupByPeriod);
  $: evolutionStats = calculateEvolutionStats(filteredEvents);
  $: impactAnalysis = analyzeImpact(filteredEvents);

  onMount(() => {
    loadArchitectureHistory();
  });

  async function loadArchitectureHistory() {
    isLoading = true;
    try {
      // Simulate loading architecture events
      await new Promise(resolve => setTimeout(resolve, 1000));
      
      timelineData = [
        {
          id: '1',
          timestamp: Date.now() - 7 * 24 * 60 * 60 * 1000,
          title: 'Cognitive State Monitoring Implementation',
          description: 'Implemented real-time cognitive state tracking with WebSocket integration',
          category: 'capability',
          impact: 'high',
          type: 'feature',
          author: 'System',
          changes: [
            'Added CognitiveStateMonitor component',
            'Implemented WebSocket real-time updates',
            'Created cognitive state store'
          ],
          metrics: {
            performance: { before: 0.6, after: 0.85 },
            reliability: { before: 0.7, after: 0.92 },
            complexity: { before: 0.4, after: 0.6 }
          },
          files: ['CognitiveStateMonitor.svelte', 'cognitiveStore.js', 'websocket.js']
        },
        {
          id: '2',
          timestamp: Date.now() - 5 * 24 * 60 * 60 * 1000,
          title: 'System Evolution Dashboard',
          description: 'Created comprehensive dashboard for tracking system evolution and capabilities',
          category: 'capability',
          impact: 'high',
          type: 'feature',
          author: 'System',
          changes: [
            'Built SystemEvolutionDashboard component',
            'Added capability tracking metrics',
            'Implemented evolution timeline visualization'
          ],
          metrics: {
            performance: { before: 0.85, after: 0.88 },
            usability: { before: 0.6, after: 0.9 },
            insights: { before: 0.5, after: 0.85 }
          },
          files: ['SystemEvolutionDashboard.svelte', 'evolutionStore.js']
        },
        {
          id: '3',
          timestamp: Date.now() - 3 * 24 * 60 * 60 * 1000,
          title: 'Collaborative Reasoning Integration',
          description: 'Added multi-agent reasoning capabilities with real-time collaboration',
          category: 'integration',
          impact: 'high',
          type: 'feature',
          author: 'System',
          changes: [
            'Implemented CollaborativeReasoningSession component',
            'Added multi-agent communication protocol',
            'Created shared reasoning state management'
          ],
          metrics: {
            collaboration: { before: 0.3, after: 0.85 },
            reasoning: { before: 0.7, after: 0.9 },
            efficiency: { before: 0.6, after: 0.8 }
          },
          files: ['CollaborativeReasoningSession.svelte', 'collaborationStore.js']
        },
        {
          id: '4',
          timestamp: Date.now() - 2 * 24 * 60 * 60 * 1000,
          title: 'Smart Knowledge Import System',
          description: 'Built intelligent knowledge import with auto-detection and processing',
          category: 'capability',
          impact: 'medium',
          type: 'feature',
          author: 'System',
          changes: [
            'Created SmartKnowledgeImport component',
            'Implemented auto-format detection',
            'Added knowledge graph integration'
          ],
          metrics: {
            automation: { before: 0.4, after: 0.85 },
            accuracy: { before: 0.6, after: 0.9 },
            speed: { before: 0.5, after: 0.8 }
          },
          files: ['SmartKnowledgeImport.svelte', 'knowledgeStore.js']
        },
        {
          id: '5',
          timestamp: Date.now() - 1 * 24 * 60 * 60 * 1000,
          title: 'Performance Optimization',
          description: 'Optimized rendering and state management for better performance',
          category: 'performance',
          impact: 'medium',
          type: 'optimization',
          author: 'System',
          changes: [
            'Optimized component re-rendering',
            'Implemented store subscriptions cleanup',
            'Added virtual scrolling for large datasets'
          ],
          metrics: {
            performance: { before: 0.75, after: 0.92 },
            memory: { before: 0.6, after: 0.85 },
            responsiveness: { before: 0.7, after: 0.95 }
          },
          files: ['multiple components', 'stores optimization']
        },
        {
          id: '6',
          timestamp: Date.now() - 6 * 60 * 60 * 1000,
          title: 'Reflection Visualizer',
          description: 'Added comprehensive reflection analysis and visualization',
          category: 'capability',
          impact: 'high',
          type: 'feature',
          author: 'System',
          changes: [
            'Implemented ReflectionVisualizer component',
            'Added pattern recognition algorithms',
            'Created insight extraction system'
          ],
          metrics: {
            insights: { before: 0.5, after: 0.9 },
            visualization: { before: 0.6, after: 0.95 },
            analysis: { before: 0.4, after: 0.85 }
          },
          files: ['ReflectionVisualizer.svelte', 'reflectionStore.js']
        }
      ];

      // Update architecture history store
      architectureHistory.set(timelineData);
    } catch (error) {
      console.error('Failed to load architecture history:', error);
    } finally {
      isLoading = false;
    }
  }

  function filterTimelineEvents(events, query, timeRange, category) {
    const now = Date.now();
    const timeMs = {
      '1d': 24 * 60 * 60 * 1000,
      '1w': 7 * 24 * 60 * 60 * 1000,
      '1m': 30 * 24 * 60 * 60 * 1000,
      '3m': 90 * 24 * 60 * 60 * 1000,
      '1y': 365 * 24 * 60 * 60 * 1000
    }[timeRange];

    return events.filter(event => {
      const timeMatch = timeRange === 'all' || (now - event.timestamp) <= timeMs;
      const categoryMatch = category === 'all' || event.category === category;
      const queryMatch = !query || 
        event.title.toLowerCase().includes(query.toLowerCase()) ||
        event.description.toLowerCase().includes(query.toLowerCase()) ||
        event.changes.some(change => change.toLowerCase().includes(query.toLowerCase()));
      
      return timeMatch && categoryMatch && queryMatch;
    }).sort((a, b) => {
      if (viewMode === 'chronological') {
        return b.timestamp - a.timestamp;
      } else if (viewMode === 'impact') {
        const impactOrder = { 'high': 3, 'medium': 2, 'low': 1 };
        return impactOrder[b.impact] - impactOrder[a.impact];
      } else {
        return a.category.localeCompare(b.category);
      }
    });
  }

  function groupEventsByPeriod(events, period) {
    const groups = new Map();
    
    events.forEach(event => {
      const date = new Date(event.timestamp);
      let key;
      
      switch (period) {
        case 'hour':
          key = `${date.getFullYear()}-${date.getMonth()}-${date.getDate()}-${date.getHours()}`;
          break;
        case 'day':
          key = `${date.getFullYear()}-${date.getMonth()}-${date.getDate()}`;
          break;
        case 'week':
          const weekStart = new Date(date);
          weekStart.setDate(date.getDate() - date.getDay());
          key = `${weekStart.getFullYear()}-W${Math.floor(weekStart.getTime() / (7 * 24 * 60 * 60 * 1000))}`;
          break;
        case 'month':
          key = `${date.getFullYear()}-${date.getMonth()}`;
          break;
        default:
          key = date.toDateString();
      }
      
      if (!groups.has(key)) {
        groups.set(key, {
          period: key,
          events: [],
          metrics: { performance: 0, impact: 0, complexity: 0 }
        });
      }
      
      groups.get(key).events.push(event);
    });

    return Array.from(groups.values()).sort((a, b) => 
      new Date(b.events[0].timestamp) - new Date(a.events[0].timestamp)
    );
  }

  function calculateEvolutionStats(events) {
    const total = events.length;
    const byCategory = events.reduce((acc, event) => {
      acc[event.category] = (acc[event.category] || 0) + 1;
      return acc;
    }, {});

    const byImpact = events.reduce((acc, event) => {
      acc[event.impact] = (acc[event.impact] || 0) + 1;
      return acc;
    }, {});

    const averageMetrics = events.reduce((acc, event) => {
      Object.entries(event.metrics || {}).forEach(([key, value]) => {
        if (!acc[key]) acc[key] = { before: 0, after: 0, count: 0 };
        acc[key].before += value.before || 0;
        acc[key].after += value.after || 0;
        acc[key].count++;
      });
      return acc;
    }, {});

    Object.keys(averageMetrics).forEach(key => {
      const metric = averageMetrics[key];
      metric.before /= metric.count;
      metric.after /= metric.count;
      metric.improvement = ((metric.after - metric.before) / metric.before * 100).toFixed(1);
    });

    return {
      total,
      byCategory,
      byImpact,
      averageMetrics
    };
  }

  function analyzeImpact(events) {
    const impactScore = events.reduce((score, event) => {
      const weights = { 'high': 3, 'medium': 2, 'low': 1 };
      return score + weights[event.impact];
    }, 0);

    const recentEvents = events.filter(event => 
      Date.now() - event.timestamp < 7 * 24 * 60 * 60 * 1000
    );

    const momentum = recentEvents.length / Math.max(events.length, 1);

    return {
      score: impactScore,
      momentum: momentum * 100,
      recentCount: recentEvents.length,
      trend: momentum > 0.3 ? 'accelerating' : momentum > 0.1 ? 'steady' : 'slowing'
    };
  }

  function selectEvent(event) {
    selectedEvent = event;
    dispatch('eventSelected', { event });
  }

  function exportTimeline() {
    const exportData = {
      events: filteredEvents,
      stats: evolutionStats,
      impact: impactAnalysis,
      metadata: {
        exportDate: new Date().toISOString(),
        filters: { timeRange, filterCategory, viewMode },
        query: searchQuery
      }
    };

    const blob = new Blob([JSON.stringify(exportData, null, 2)], {
      type: 'application/json'
    });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `architecture-timeline-${Date.now()}.json`;
    a.click();
    URL.revokeObjectURL(url);
  }

  function getImpactColor(impact) {
    return {
      'high': '#ef4444',
      'medium': '#f59e0b',
      'low': '#10b981'
    }[impact] || '#6b7280';
  }

  function getCategoryIcon(category) {
    return {
      'capability': '🚀',
      'performance': '⚡',
      'integration': '🔗',
      'bug-fix': '🐛',
      'optimization': '⚙️'
    }[category] || '📝';
  }
</script>

<div class="architecture-timeline" transition:fade={{ duration: 300 }}>
  <!-- Header Section -->
  <div class="timeline-header">
    <div class="header-left">
      <h2>Architecture Timeline</h2>
      <div class="timeline-stats">
        <div class="stat-card">
          <span class="stat-value">{evolutionStats.total}</span>
          <span class="stat-label">Total Events</span>
        </div>
        <div class="stat-card">
          <span class="stat-value">{impactAnalysis.recentCount}</span>
          <span class="stat-label">Recent Changes</span>
        </div>
        <div class="stat-card">
          <span class="stat-value">{impactAnalysis.momentum.toFixed(0)}%</span>
          <span class="stat-label">Momentum</span>
        </div>
        <div class="stat-card trend-{impactAnalysis.trend}">
          <span class="stat-value">{impactAnalysis.trend}</span>
          <span class="stat-label">Trend</span>
        </div>
      </div>
    </div>

    <div class="header-controls">
      <div class="search-container">
        <input 
          type="text" 
          placeholder="Search timeline events..."
          bind:value={searchQuery}
          class="search-input"
        />
        <button class="search-clear" on:click={() => searchQuery = ''}>×</button>
      </div>

      <div class="filter-controls">
        <select bind:value={timeRange} class="filter-select">
          <option value="all">All Time</option>
          <option value="1d">Last Day</option>
          <option value="1w">Last Week</option>
          <option value="1m">Last Month</option>
          <option value="3m">Last 3 Months</option>
          <option value="1y">Last Year</option>
        </select>

        <select bind:value={filterCategory} class="filter-select">
          <option value="all">All Categories</option>
          <option value="capability">Capability</option>
          <option value="performance">Performance</option>
          <option value="integration">Integration</option>
          <option value="bug-fix">Bug Fix</option>
          <option value="optimization">Optimization</option>
        </select>

        <select bind:value={viewMode} class="filter-select">
          <option value="chronological">Chronological</option>
          <option value="impact">By Impact</option>
          <option value="category">By Category</option>
        </select>

        <select bind:value={groupByPeriod} class="filter-select">
          <option value="hour">Group by Hour</option>
          <option value="day">Group by Day</option>
          <option value="week">Group by Week</option>
          <option value="month">Group by Month</option>
        </select>
      </div>

      <div class="action-controls">
        <button 
          class="toggle-metrics"
          class:active={showMetrics}
          on:click={() => showMetrics = !showMetrics}
        >
          {showMetrics ? 'Hide' : 'Show'} Metrics
        </button>

        <button class="export-btn" on:click={exportTimeline}>
          Export Timeline
        </button>
      </div>
    </div>
  </div>

  <!-- Metrics Panel -->
  {#if showMetrics}
    <div class="metrics-panel" transition:slide={{ duration: 300 }}>
      <div class="metrics-grid">
        <div class="metric-group">
          <h4>Evolution Metrics</h4>
          <div class="metrics-list">
            {#each Object.entries(evolutionStats.averageMetrics) as [key, metric]}
              <div class="metric-item">
                <span class="metric-name">{key}</span>
                <div class="metric-progress">
                  <div class="progress-bar">
                    <div 
                      class="progress-fill before" 
                      style="width: {metric.before * 100}%"
                    ></div>
                    <div 
                      class="progress-fill after" 
                      style="width: {metric.after * 100}%"
                    ></div>
                  </div>
                  <span class="metric-improvement" class:positive={metric.improvement > 0}>
                    {metric.improvement > 0 ? '+' : ''}{metric.improvement}%
                  </span>
                </div>
              </div>
            {/each}
          </div>
        </div>

        <div class="metric-group">
          <h4>Category Distribution</h4>
          <div class="category-chart">
            {#each Object.entries(evolutionStats.byCategory) as [category, count]}
              <div class="category-bar">
                <span class="category-name">
                  {getCategoryIcon(category)} {category}
                </span>
                <div class="bar-container">
                  <div 
                    class="bar-fill"
                    style="width: {(count / evolutionStats.total) * 100}%"
                  ></div>
                  <span class="count">{count}</span>
                </div>
              </div>
            {/each}
          </div>
        </div>

        <div class="metric-group">
          <h4>Impact Analysis</h4>
          <div class="impact-chart">
            {#each Object.entries(evolutionStats.byImpact) as [impact, count]}
              <div class="impact-item">
                <span class="impact-label" style="color: {getImpactColor(impact)}">
                  {impact} impact
                </span>
                <div class="impact-bar">
                  <div 
                    class="impact-fill"
                    style="width: {(count / evolutionStats.total) * 100}%; background: {getImpactColor(impact)}"
                  ></div>
                  <span class="impact-count">{count}</span>
                </div>
              </div>
            {/each}
          </div>
        </div>
      </div>
    </div>
  {/if}

  <!-- Timeline Content -->
  <div class="timeline-content">
    {#if isLoading}
      <div class="loading-state" transition:fade>
        <div class="loading-spinner"></div>
        <p>Loading architecture timeline...</p>
      </div>
    {:else if filteredEvents.length === 0}
      <div class="empty-state" transition:fade>
        <div class="empty-icon">📅</div>
        <h3>No events found</h3>
        <p>Try adjusting your filters or search criteria</p>
      </div>
    {:else}
      <div class="timeline-container">
        {#each groupedEvents as group, groupIndex (group.period)}
          <div 
            class="timeline-group"
            transition:fly={{ y: 20, duration: 300, delay: groupIndex * 100 }}
          >
            <div class="group-header">
              <h3 class="group-title">{group.period}</h3>
              <span class="group-count">{group.events.length} events</span>
            </div>

            <div class="group-events">
              {#each group.events as event, eventIndex (event.id)}
                <div 
                  class="timeline-event"
                  class:selected={selectedEvent?.id === event.id}
                  transition:scale={{ 
                    duration: 200, 
                    delay: (groupIndex * 100) + (eventIndex * 50),
                    easing: quintOut 
                  }}
                  on:click={() => selectEvent(event)}
                >
                  <div class="event-marker">
                    <div 
                      class="marker-dot"
                      style="background: {getImpactColor(event.impact)}"
                    ></div>
                    <div class="marker-line"></div>
                  </div>

                  <div class="event-content">
                    <div class="event-header">
                      <div class="event-title-row">
                        <span class="event-icon">{getCategoryIcon(event.category)}</span>
                        <h4 class="event-title">{event.title}</h4>
                        <span class="event-category">{event.category}</span>
                      </div>
                      <div class="event-meta">
                        <span class="event-time">
                          {new Date(event.timestamp).toLocaleString()}
                        </span>
                        <span class="event-impact impact-{event.impact}">
                          {event.impact} impact
                        </span>
                        <span class="event-type">{event.type}</span>
                      </div>
                    </div>

                    <p class="event-description">{event.description}</p>

                    <div class="event-changes">
                      <h5>Changes:</h5>
                      <ul>
                        {#each event.changes as change}
                          <li>{change}</li>
                        {/each}
                      </ul>
                    </div>

                    {#if event.metrics && Object.keys(event.metrics).length > 0}
                      <div class="event-metrics">
                        <h5>Impact Metrics:</h5>
                        <div class="metrics-row">
                          {#each Object.entries(event.metrics) as [key, metric]}
                            <div class="metric-badge">
                              <span class="metric-key">{key}</span>
                              <div class="metric-change">
                                <span class="before">{(metric.before * 100).toFixed(0)}%</span>
                                <span class="arrow">→</span>
                                <span class="after">{(metric.after * 100).toFixed(0)}%</span>
                              </div>
                            </div>
                          {/each}
                        </div>
                      </div>
                    {/if}

                    <div class="event-footer">
                      <div class="event-files">
                        <span class="files-label">Files:</span>
                        {#each event.files as file}
                          <span class="file-tag">{file}</span>
                        {/each}
                      </div>
                      <span class="event-author">by {event.author}</span>
                    </div>
                  </div>
                </div>
              {/each}
            </div>
          </div>
        {/each}
      </div>
    {/if}
  </div>

  <!-- Event Detail Modal -->
  {#if selectedEvent}
    <div 
      class="event-detail-modal"
      transition:fly={{ y: 50, duration: 300, easing: cubicOut }}
      on:click|self={() => selectedEvent = null}
    >
      <div class="modal-content">
        <div class="modal-header">
          <div class="modal-title-row">
            <span class="modal-icon">{getCategoryIcon(selectedEvent.category)}</span>
            <h3>{selectedEvent.title}</h3>
            <button class="close-modal" on:click={() => selectedEvent = null}>×</button>
          </div>
          <div class="modal-meta">
            <span class="modal-time">
              {new Date(selectedEvent.timestamp).toLocaleString()}
            </span>
            <span class="modal-category">{selectedEvent.category}</span>
            <span class="modal-impact impact-{selectedEvent.impact}">
              {selectedEvent.impact} impact
            </span>
          </div>
        </div>

        <div class="modal-body">
          <div class="modal-description">
            <h4>Description</h4>
            <p>{selectedEvent.description}</p>
          </div>

          <div class="modal-changes">
            <h4>Detailed Changes</h4>
            <ul>
              {#each selectedEvent.changes as change}
                <li>{change}</li>
              {/each}
            </ul>
          </div>

          {#if selectedEvent.metrics}
            <div class="modal-metrics">
              <h4>Performance Impact</h4>
              <div class="detailed-metrics">
                {#each Object.entries(selectedEvent.metrics) as [key, metric]}
                  <div class="detailed-metric">
                    <div class="metric-header">
                      <span class="metric-name">{key}</span>
                      <span class="metric-improvement">
                        {((metric.after - metric.before) / metric.before * 100).toFixed(1)}% improvement
                      </span>
                    </div>
                    <div class="metric-bars">
                      <div class="metric-bar before">
                        <label>Before</label>
                        <div class="bar">
                          <div 
                            class="bar-fill"
                            style="width: {metric.before * 100}%"
                          ></div>
                        </div>
                        <span>{(metric.before * 100).toFixed(0)}%</span>
                      </div>
                      <div class="metric-bar after">
                        <label>After</label>
                        <div class="bar">
                          <div 
                            class="bar-fill"
                            style="width: {metric.after * 100}%"
                          ></div>
                        </div>
                        <span>{(metric.after * 100).toFixed(0)}%</span>
                      </div>
                    </div>
                  </div>
                {/each}
              </div>
            </div>
          {/if}

          <div class="modal-files">
            <h4>Modified Files</h4>
            <div class="files-grid">
              {#each selectedEvent.files as file}
                <div class="file-card">
                  <span class="file-icon">📄</span>
                  <span class="file-name">{file}</span>
                </div>
              {/each}
            </div>
          </div>
        </div>
      </div>
    </div>
  {/if}
</div>

<style>
  .architecture-timeline {
    display: flex;
    flex-direction: column;
    height: 100vh;
    background: linear-gradient(135deg, #1e3a8a 0%, #3730a3 50%, #581c87 100%);
    color: white;
    font-family: 'Inter', sans-serif;
    overflow: hidden;
  }

  .timeline-header {
    display: flex;
    justify-content: space-between;
    align-items: flex-start;
    padding: 1.5rem 2rem;
    background: rgba(255, 255, 255, 0.1);
    backdrop-filter: blur(20px);
    border-bottom: 1px solid rgba(255, 255, 255, 0.2);
    flex-shrink: 0;
  }

  .header-left h2 {
    margin: 0 0 1rem 0;
    font-size: 1.8rem;
    font-weight: 700;
  }

  .timeline-stats {
    display: flex;
    gap: 1rem;
  }

  .stat-card {
    display: flex;
    flex-direction: column;
    align-items: center;
    padding: 0.75rem 1rem;
    background: rgba(255, 255, 255, 0.1);
    border-radius: 0.5rem;
    min-width: 80px;
  }

  .stat-value {
    font-size: 1.5rem;
    font-weight: 700;
    color: #a7f3d0;
  }

  .stat-label {
    font-size: 0.75rem;
    opacity: 0.8;
    text-align: center;
  }

  .trend-accelerating .stat-value { color: #34d399; }
  .trend-steady .stat-value { color: #fbbf24; }
  .trend-slowing .stat-value { color: #f87171; }

  .header-controls {
    display: flex;
    flex-direction: column;
    gap: 1rem;
    align-items: flex-end;
  }

  .search-container {
    position: relative;
  }

  .search-input {
    padding: 0.5rem 2rem 0.5rem 1rem;
    border: 1px solid rgba(255, 255, 255, 0.3);
    border-radius: 0.5rem;
    background: rgba(255, 255, 255, 0.1);
    color: white;
    backdrop-filter: blur(10px);
    width: 300px;
  }

  .search-input::placeholder {
    color: rgba(255, 255, 255, 0.6);
  }

  .search-clear {
    position: absolute;
    right: 0.5rem;
    top: 50%;
    transform: translateY(-50%);
    background: none;
    border: none;
    color: white;
    cursor: pointer;
    font-size: 1.2rem;
  }

  .filter-controls {
    display: flex;
    gap: 0.5rem;
    flex-wrap: wrap;
  }

  .filter-select {
    padding: 0.5rem;
    border: 1px solid rgba(255, 255, 255, 0.3);
    border-radius: 0.375rem;
    background: rgba(255, 255, 255, 0.1);
    color: white;
    backdrop-filter: blur(10px);
    font-size: 0.9rem;
  }

  .action-controls {
    display: flex;
    gap: 0.5rem;
  }

  .toggle-metrics, .export-btn {
    padding: 0.5rem 1rem;
    border: 1px solid rgba(255, 255, 255, 0.3);
    border-radius: 0.375rem;
    background: rgba(255, 255, 255, 0.1);
    color: white;
    cursor: pointer;
    transition: all 0.2s ease;
    font-size: 0.9rem;
  }

  .toggle-metrics:hover, .export-btn:hover {
    background: rgba(255, 255, 255, 0.2);
    transform: translateY(-1px);
  }

  .toggle-metrics.active {
    background: rgba(167, 243, 208, 0.3);
    color: #a7f3d0;
  }

  .metrics-panel {
    padding: 1.5rem 2rem;
    background: rgba(255, 255, 255, 0.05);
    border-bottom: 1px solid rgba(255, 255, 255, 0.1);
    flex-shrink: 0;
  }

  .metrics-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
    gap: 2rem;
  }

  .metric-group h4 {
    margin: 0 0 1rem 0;
    font-size: 1.1rem;
    font-weight: 600;
    color: #a7f3d0;
  }

  .metric-item {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 0.75rem;
  }

  .metric-name {
    font-weight: 500;
    text-transform: capitalize;
  }

  .metric-progress {
    display: flex;
    align-items: center;
    gap: 0.5rem;
  }

  .progress-bar {
    width: 100px;
    height: 6px;
    background: rgba(255, 255, 255, 0.2);
    border-radius: 3px;
    overflow: hidden;
    position: relative;
  }

  .progress-fill {
    height: 100%;
    position: absolute;
    top: 0;
    border-radius: 3px;
    transition: width 0.3s ease;
  }

  .progress-fill.before {
    background: rgba(239, 68, 68, 0.6);
  }

  .progress-fill.after {
    background: linear-gradient(90deg, #34d399, #a7f3d0);
  }

  .metric-improvement {
    font-size: 0.8rem;
    font-weight: 600;
    min-width: 50px;
    text-align: right;
  }

  .metric-improvement.positive {
    color: #34d399;
  }

  .category-chart, .impact-chart {
    space-y: 0.75rem;
  }

  .category-bar, .impact-item {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 0.75rem;
  }

  .category-name, .impact-label {
    font-weight: 500;
    min-width: 120px;
  }

  .bar-container, .impact-bar {
    display: flex;
    align-items: center;
    gap: 0.5rem;
    flex: 1;
  }

  .bar-fill, .impact-fill {
    height: 6px;
    background: linear-gradient(90deg, #3b82f6, #8b5cf6);
    border-radius: 3px;
    transition: width 0.3s ease;
  }

  .count, .impact-count {
    font-size: 0.8rem;
    font-weight: 600;
    min-width: 30px;
    text-align: right;
  }

  .timeline-content {
    flex: 1;
    padding: 1rem 2rem;
    overflow-y: auto;
    overflow-x: hidden;
  }

  .loading-state, .empty-state {
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    height: 100%;
  }

  .loading-spinner {
    width: 3rem;
    height: 3rem;
    border: 3px solid rgba(255, 255, 255, 0.3);
    border-top: 3px solid white;
    border-radius: 50%;
    animation: spin 1s linear infinite;
    margin-bottom: 1rem;
  }

  .empty-icon {
    font-size: 4rem;
    margin-bottom: 1rem;
  }

  .empty-state h3 {
    margin: 0 0 0.5rem 0;
    font-size: 1.5rem;
    font-weight: 600;
  }

  .empty-state p {
    margin: 0;
    opacity: 0.7;
  }

  .timeline-container {
    max-width: 1000px;
    margin: 0 auto;
  }

  .timeline-group {
    margin-bottom: 3rem;
  }

  .group-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 1.5rem;
    padding-bottom: 0.5rem;
    border-bottom: 2px solid rgba(255, 255, 255, 0.2);
  }

  .group-title {
    margin: 0;
    font-size: 1.3rem;
    font-weight: 600;
    color: #a7f3d0;
  }

  .group-count {
    font-size: 0.9rem;
    opacity: 0.7;
  }

  .group-events {
    position: relative;
  }

  .timeline-event {
    display: flex;
    margin-bottom: 2rem;
    cursor: pointer;
    transition: all 0.3s ease;
  }

  .timeline-event:hover {
    transform: translateY(-2px);
  }

  .timeline-event.selected {
    transform: scale(1.02);
    filter: drop-shadow(0 0 15px rgba(167, 243, 208, 0.3));
  }

  .event-marker {
    display: flex;
    flex-direction: column;
    align-items: center;
    margin-right: 2rem;
    z-index: 1;
  }

  .marker-dot {
    width: 1.25rem;
    height: 1.25rem;
    border-radius: 50%;
    border: 3px solid rgba(255, 255, 255, 0.3);
    flex-shrink: 0;
    position: relative;
    z-index: 2;
  }

  .marker-line {
    width: 2px;
    height: 150px;
    background: rgba(255, 255, 255, 0.2);
    margin-top: 0.5rem;
  }

  .event-content {
    flex: 1;
    background: rgba(255, 255, 255, 0.1);
    border-radius: 1rem;
    padding: 1.5rem;
    backdrop-filter: blur(15px);
    border: 1px solid rgba(255, 255, 255, 0.2);
  }

  .event-header {
    margin-bottom: 1rem;
  }

  .event-title-row {
    display: flex;
    align-items: center;
    gap: 0.75rem;
    margin-bottom: 0.5rem;
  }

  .event-icon {
    font-size: 1.5rem;
  }

  .event-title {
    margin: 0;
    font-size: 1.2rem;
    font-weight: 600;
    flex: 1;
  }

  .event-category {
    padding: 0.25rem 0.75rem;
    background: rgba(255, 255, 255, 0.2);
    border-radius: 0.375rem;
    font-size: 0.8rem;
    text-transform: capitalize;
  }

  .event-meta {
    display: flex;
    gap: 1rem;
    flex-wrap: wrap;
  }

  .event-time, .event-type {
    font-size: 0.8rem;
    opacity: 0.8;
  }

  .event-impact {
    padding: 0.25rem 0.5rem;
    border-radius: 0.375rem;
    font-size: 0.8rem;
    font-weight: 500;
  }

  .impact-high {
    background: rgba(239, 68, 68, 0.3);
    color: #fca5a5;
  }

  .impact-medium {
    background: rgba(249, 115, 22, 0.3);
    color: #fdba74;
  }

  .impact-low {
    background: rgba(34, 197, 94, 0.3);
    color: #a7f3d0;
  }

  .event-description {
    margin-bottom: 1rem;
    line-height: 1.6;
    opacity: 0.9;
  }

  .event-changes {
    margin-bottom: 1rem;
  }

  .event-changes h5 {
    margin: 0 0 0.5rem 0;
    font-size: 0.9rem;
    font-weight: 600;
    color: #a7f3d0;
  }

  .event-changes ul {
    margin: 0;
    padding-left: 1.5rem;
  }

  .event-changes li {
    margin-bottom: 0.25rem;
    font-size: 0.9rem;
    line-height: 1.4;
  }

  .event-metrics {
    margin-bottom: 1rem;
  }

  .event-metrics h5 {
    margin: 0 0 0.75rem 0;
    font-size: 0.9rem;
    font-weight: 600;
    color: #a7f3d0;
  }

  .metrics-row {
    display: flex;
    gap: 1rem;
    flex-wrap: wrap;
  }

  .metric-badge {
    background: rgba(255, 255, 255, 0.1);
    padding: 0.5rem 0.75rem;
    border-radius: 0.5rem;
    text-align: center;
  }

  .metric-key {
    display: block;
    font-size: 0.8rem;
    font-weight: 500;
    margin-bottom: 0.25rem;
    text-transform: capitalize;
  }

  .metric-change {
    display: flex;
    align-items: center;
    gap: 0.25rem;
    font-size: 0.8rem;
  }

  .before {
    opacity: 0.7;
  }

  .arrow {
    color: #a7f3d0;
  }

  .after {
    color: #34d399;
    font-weight: 600;
  }

  .event-footer {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding-top: 1rem;
    border-top: 1px solid rgba(255, 255, 255, 0.1);
  }

  .event-files {
    display: flex;
    align-items: center;
    gap: 0.5rem;
    flex-wrap: wrap;
  }

  .files-label {
    font-size: 0.8rem;
    font-weight: 500;
    opacity: 0.8;
  }

  .file-tag {
    padding: 0.25rem 0.5rem;
    background: rgba(255, 255, 255, 0.2);
    border-radius: 0.375rem;
    font-size: 0.7rem;
    font-family: 'Monaco', monospace;
  }

  .event-author {
    font-size: 0.8rem;
    font-style: italic;
    opacity: 0.7;
  }

  .event-detail-modal {
    position: fixed;
    top: 0;
    left: 0;
    width: 100vw;
    height: 100vh;
    background: rgba(0, 0, 0, 0.8);
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 1000;
    backdrop-filter: blur(5px);
  }

  .modal-content {
    background: rgba(30, 58, 138, 0.95);
    border-radius: 1rem;
    max-width: 800px;
    max-height: 90vh;
    margin: 2rem;
    overflow: hidden;
    border: 1px solid rgba(255, 255, 255, 0.2);
    backdrop-filter: blur(20px);
  }

  .modal-header {
    padding: 2rem 2rem 1rem 2rem;
    border-bottom: 1px solid rgba(255, 255, 255, 0.1);
  }

  .modal-title-row {
    display: flex;
    align-items: center;
    gap: 1rem;
    margin-bottom: 0.75rem;
  }

  .modal-icon {
    font-size: 2rem;
  }

  .modal-title-row h3 {
    margin: 0;
    font-size: 1.5rem;
    font-weight: 600;
    flex: 1;
  }

  .close-modal {
    background: none;
    border: none;
    color: white;
    font-size: 2rem;
    cursor: pointer;
    padding: 0.25rem;
    opacity: 0.7;
    transition: opacity 0.2s ease;
  }

  .close-modal:hover {
    opacity: 1;
  }

  .modal-meta {
    display: flex;
    gap: 1rem;
    flex-wrap: wrap;
  }

  .modal-time, .modal-category {
    font-size: 0.9rem;
    opacity: 0.8;
  }

  .modal-impact {
    padding: 0.25rem 0.75rem;
    border-radius: 0.375rem;
    font-size: 0.9rem;
    font-weight: 500;
  }

  .modal-body {
    padding: 1.5rem 2rem 2rem 2rem;
    overflow-y: auto;
    max-height: calc(90vh - 200px);
  }

  .modal-description, .modal-changes, .modal-metrics, .modal-files {
    margin-bottom: 2rem;
  }

  .modal-body h4 {
    margin: 0 0 1rem 0;
    font-size: 1.1rem;
    font-weight: 600;
    color: #a7f3d0;
  }

  .modal-description p {
    margin: 0;
    line-height: 1.6;
    font-size: 1rem;
  }

  .modal-changes ul {
    margin: 0;
    padding-left: 1.5rem;
  }

  .modal-changes li {
    margin-bottom: 0.5rem;
    line-height: 1.5;
  }

  .detailed-metrics {
    space-y: 1.5rem;
  }

  .detailed-metric {
    background: rgba(255, 255, 255, 0.05);
    padding: 1rem;
    border-radius: 0.5rem;
    margin-bottom: 1.5rem;
  }

  .metric-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 1rem;
  }

  .metric-name {
    font-weight: 600;
    text-transform: capitalize;
  }

  .metric-improvement {
    color: #34d399;
    font-weight: 600;
  }

  .metric-bars {
    display: grid;
    gap: 0.5rem;
  }

  .metric-bar {
    display: flex;
    align-items: center;
    gap: 1rem;
  }

  .metric-bar label {
    min-width: 60px;
    font-size: 0.9rem;
    font-weight: 500;
  }

  .bar {
    flex: 1;
    height: 8px;
    background: rgba(255, 255, 255, 0.2);
    border-radius: 4px;
    overflow: hidden;
  }

  .metric-bar .bar-fill {
    height: 100%;
    border-radius: 4px;
    transition: width 0.3s ease;
  }

  .metric-bar.before .bar-fill {
    background: rgba(239, 68, 68, 0.6);
  }

  .metric-bar.after .bar-fill {
    background: linear-gradient(90deg, #34d399, #a7f3d0);
  }

  .metric-bar span {
    min-width: 50px;
    text-align: right;
    font-size: 0.9rem;
    font-weight: 600;
  }

  .files-grid {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
    gap: 0.75rem;
  }

  .file-card {
    display: flex;
    align-items: center;
    gap: 0.5rem;
    background: rgba(255, 255, 255, 0.1);
    padding: 0.75rem;
    border-radius: 0.5rem;
  }

  .file-icon {
    font-size: 1.2rem;
  }

  .file-name {
    font-family: 'Monaco', monospace;
    font-size: 0.8rem;
  }

  @keyframes spin {
    0% { transform: rotate(0deg); }
    100% { transform: rotate(360deg); }
  }
</style>
```

## Implementation Strategy

### Phase 1: Structure Cleanup (Week 1)
1. **Remove HTML duplication** - eliminate duplicate transparency panels
2. **Consolidate JavaScript modules** - reduce from 28 to 6 modules
3. **Simplify CSS structure** - create unified component system

### Phase 2: Interface Redesign (Week 2)
1. **Implement unified query interface** - single-focus design
2. **Create contextual transparency** - progressive disclosure system
3. **Build smart knowledge import** - prominent, auto-detecting interface

### Phase 3: Visual Polish (Week 3)
1. **Apply new design system** - colors, typography, components
2. **Optimize interactions** - smooth animations, clear feedback
3. **Performance optimization** - reduce JavaScript payload

### Phase 4: Testing & Refinement (Week 4)
1. **User testing** - validate simplified interface
2. **Performance testing** - ensure fast response times
3. **Accessibility audit** - ensure inclusive design

## Success Metrics

### Quantitative Goals
- **Reduce JavaScript payload by 60%** (28 modules → 6 modules)
- **Eliminate code duplication** (remove duplicate HTML sections)
- **Improve Wikipedia import discoverability** (prominent vs buried)
- **Reduce cognitive load** (single interface vs fragmented panels)

### Qualitative Goals
- **Intuitive knowledge import** - users find Wikipedia upload immediately
- **Clear cognitive transparency** - users understand reasoning when needed
- **Unified experience** - no confusion about duplicate interfaces
- **Progressive complexity** - simple by default, detailed on demand

## Technical Requirements

### Browser Support
- Chrome 100+, Firefox 100+, Safari 15+, Edge 100+
- Mobile responsive (tablet/phone)
- Keyboard navigation
- Screen reader compatibility

### Performance Targets
- **First Contentful Paint**: <1.5s
- **Largest Contentful Paint**: <2.5s
- **Cumulative Layout Shift**: <0.1
- **First Input Delay**: <100ms

### API Integration
- Maintain compatibility with existing backend APIs
- Utilize WebSocket streaming for real-time updates
- Handle offline scenarios gracefully

## Implementation Integration Guide

### Real-Time Cognitive State API Integration

```javascript
// WebSocket connection for live cognitive state monitoring
class CognitiveStateMonitor {
  constructor() {
    this.ws = new WebSocket('ws://localhost:8000/ws/cognitive_state');
    this.subscribers = new Map();
  }
  
  subscribe(component, callback) {
    this.subscribers.set(component, callback);
  }
  
  handleMessage(data) {
    const cognitiveEvent = JSON.parse(data);
    
    switch(cognitiveEvent.type) {
      case 'reflection_started':
        this.updateReflectionVisualization(cognitiveEvent);
        break;
      case 'knowledge_integrated':
        this.updateKnowledgeGraph(cognitiveEvent);
        break;
      case 'capability_assessment':
        this.updateCapabilityDashboard(cognitiveEvent);
        break;
      case 'modification_proposed':
        this.showModificationProposal(cognitiveEvent);
        break;
    }
  }
}
```

### Self-Modification Proposals Integration

```javascript
// Integration with backend modification proposal system
class ModificationProposalManager {
  async fetchProposals() {
    const response = await fetch('/api/metacognition/modification_proposals');
    return response.json();
  }
  
  async evaluateProposal(proposalId) {
    const response = await fetch(`/api/metacognition/evaluate_proposal/${proposalId}`);
    return response.json(); // Returns risk assessment, expected impact
  }
  
  async approveModification(proposalId) {
    const response = await fetch(`/api/metacognition/approve_modification/${proposalId}`, {
      method: 'POST'
    });
    return response.json();
  }
  
  renderProposalCard(proposal) {
    return `
      <div class="modification-proposal" data-risk="${proposal.risk_level}">
        <h3>${proposal.title}</h3>
        <p>${proposal.description}</p>
        <div class="impact-metrics">
          <span>Expected Impact: ${proposal.expected_impact}%</span>
          <span>Risk Level: ${proposal.risk_level}</span>
          <span>Confidence: ${proposal.confidence}%</span>
        </div>
        <div class="proposal-actions">
          <button onclick="approveModification('${proposal.id}')">Approve</button>
          <button onclick="rejectModification('${proposal.id}')">Reject</button>
          <button onclick="requestMoreInfo('${proposal.id}')">More Info</button>
        </div>
      </div>
    `;
  }
}
```

### Cognitive Architecture Evolution Tracking

```javascript
// Track and visualize architecture changes over time
class ArchitectureEvolutionTracker {
  async getEvolutionTimeline() {
    const response = await fetch('/api/metacognition/architecture_evolution');
    return response.json();
  }
  
  async getCurrentCapabilities() {
    const response = await fetch('/api/cognitive_engine/capabilities');
    return response.json();
  }
  
  renderEvolutionTimeline(evolution) {
    const timeline = evolution.map(event => `
      <div class="evolution-event" data-impact="${event.impact}">
        <div class="event-date">${event.timestamp}</div>
        <div class="event-title">${event.title}</div>
        <div class="event-description">${event.description}</div>
        <div class="event-metrics">
          ${event.metrics.map(metric => 
            `<span class="metric">${metric.name}: ${metric.change}</span>`
          ).join('')}
        </div>
      </div>
    `).join('');
    
    return `<div class="evolution-timeline">${timeline}</div>`;
  }
}
```

### Enhanced Knowledge Store Integration

```javascript
// Deep integration with cognitive-aware knowledge management
class CognitiveKnowledgeManager {
  async importWithCognitiveAnalysis(source, type) {
    const formData = new FormData();
    formData.append('source', source);
    formData.append('type', type);
    formData.append('cognitive_analysis', true);
    
    const response = await fetch('/api/knowledge/import', {
      method: 'POST',
      body: formData
    });
    
    return response.json(); // Returns cognitive insights + import status
  }
  
  async searchWithReasoningContext(query, reasoning_context) {
    const response = await fetch('/api/knowledge/search', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        query,
        reasoning_context,
        include_cognitive_relevance: true
      })
    });
    
    return response.json();
  }
  
  renderCognitiveKnowledgeCard(knowledge) {
    return `
      <div class="knowledge-card cognitive-enhanced">
        <div class="knowledge-content">${knowledge.content}</div>
        <div class="cognitive-insights">
          <div class="relevance-score">
            Relevance: ${knowledge.cognitive_relevance}%
          </div>
          <div class="reasoning-connections">
            Connected to: ${knowledge.reasoning_connections.join(', ')}
          </div>
          <div class="analogical-potential">
            Analogical Potential: ${knowledge.analogical_potential}
          </div>
        </div>
      </div>
    `;
  }
}
```

## Performance Optimization Strategy

### Cognitive Transparency On-Demand Loading
- **Progressive Enhancement**: Load basic interface first, cognitive transparency on user request
- **Cognitive Event Streaming**: Only stream events user is actively monitoring
- **Reflection Depth Limiting**: Limit displayed reflection depth based on user preference and performance

### Real-Time Update Throttling
```javascript
// Efficient cognitive state updates without overwhelming the UI
class PerformantCognitiveDisplay {
  constructor() {
    this.updateQueue = [];
    this.lastUpdate = 0;
    this.throttleMs = 100; // Update every 100ms max
  }
  
  queueUpdate(cognitiveEvent) {
    this.updateQueue.push(cognitiveEvent);
    this.scheduleUpdate();
  }
  
  scheduleUpdate() {
    const now = Date.now();
    if (now - this.lastUpdate > this.throttleMs) {
      this.processUpdateQueue();
      this.lastUpdate = now;
    } else {
      setTimeout(() => this.scheduleUpdate(), this.throttleMs);
    }
  }
  
  processUpdateQueue() {
    // Batch process cognitive updates
    const updates = this.updateQueue.splice(0);
    this.applyBatchedUpdates(updates);
  }
}
```

### Memory-Efficient State Management
```javascript
// Manage cognitive state without memory leaks
class CognitiveStateStore {
  constructor() {
    this.state = {
      currentReflection: null,
      knowledgeGraph: new Map(),
      capabilities: new Map(),
      modificationProposals: []
    };
    this.maxHistorySize = 100; // Limit reflection history
  }
  
  updateReflectionState(newReflection) {
    if (this.state.reflectionHistory?.length > this.maxHistorySize) {
      this.state.reflectionHistory.shift(); // Remove oldest
    }
    this.state.currentReflection = newReflection;
  }
  
  pruneOldData() {
    // Clean up old cognitive events to prevent memory bloat
    const cutoff = Date.now() - (24 * 60 * 60 * 1000); // 24 hours
    this.state.knowledgeGraph.forEach((value, key) => {
      if (value.timestamp < cutoff) {
        this.state.knowledgeGraph.delete(key);
      }
    });
  }
}
```

## Migration Strategy

### Phase 1: Foundation (Weeks 1-2)
**Deliverables:**
- Clean up duplicate HTML structures
- Implement cognitive state monitoring WebSocket connection
- Basic self-modification proposals interface
- Unified JavaScript module architecture

**Success Criteria:**
- No duplicate transparency panels
- Real-time cognitive state display functional
- Modification proposals visible and interactive

### Phase 2: Enhanced Cognitive Features (Weeks 3-4)
**Deliverables:**
- Multi-level reflection visualization
- Cognitive resource allocation display
- Architecture evolution timeline
- Enhanced knowledge import with cognitive analysis

**Success Criteria:**
- Users can observe thinking in real-time
- System self-modification process is transparent
- Knowledge integration shows cognitive insights

### Phase 3: Collaborative Intelligence (Weeks 5-6)
**Deliverables:**
- Human-AI cognitive partnership interface
- System learning from interaction tracking
- Knowledge evolution visualization
- Collaborative reasoning sessions

**Success Criteria:**
- Users can actively collaborate with GödelOS reasoning
- System visibly learns and adapts from interactions
- Bidirectional cognitive enhancement demonstrated

### Phase 4: Optimization & Polish (Weeks 7-8)
**Deliverables:**
- Performance optimization implementation
- Advanced cognitive transparency features
- Complete design system implementation
- Comprehensive user testing and refinement

**Success Criteria:**
- <1.5s load times with full cognitive monitoring
- Advanced users can access deep cognitive insights
- Interface scales gracefully with system complexity

## Conclusion

This comprehensive redesign specification transforms GödelOS from a fragmented interface into a unified cognitive transparency platform that accurately reflects the sophisticated backend architecture. The specification addresses:

### **Immediate Technical Issues Resolved:**
- **Eliminates duplicate transparency interfaces** that confuse users
- **Surfaces buried Wikipedia import functionality** with prominent, smart detection
- **Simplifies module architecture** from 28 to 6 focused modules without losing functionality
- **Creates coherent user experience** with progressive disclosure patterns

### **Advanced Cognitive Interface Capabilities:**
- **Real-time cognitive state monitoring** showing manifest consciousness, agentic processes, and daemon threads
- **Self-modification transparency** with system-generated improvement proposals and risk assessment
- **Multi-level reflection visualization** enabling users to observe thinking about thinking
- **Collaborative intelligence features** positioning users as cognitive partners rather than passive observers
- **Architecture evolution tracking** showing how the system grows and changes over time

### **Unique Value Propositions:**
1. **First AI interface to show genuine cognitive processes** - not just input/output but actual reasoning stages
2. **Transparent self-modification** - users observe and approve system improvements in real-time  
3. **Collaborative reasoning sessions** - human expertise integrated with AI capabilities for emergent insights
4. **Knowledge as living networks** - information presented as evolving, interconnected cognitive structures

### **Implementation Readiness:**
The backend is robust and complete with 28+ functional APIs, real-time WebSocket streaming, and comprehensive cognitive monitoring. Implementation can begin immediately with the structure cleanup phase, as all required backend capabilities are already functional and well-documented.

This redesign enables GödelOS to become the first AI system where users can genuinely observe, understand, and collaborate with machine consciousness - transforming AI interaction from black-box consumption to transparent cognitive partnership.
